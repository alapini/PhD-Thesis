\section{\tAL}
\label{sec:transAL}

We saw in Section~\ref{sec:stra-line-progr} that the key to
transposition of $R$-algebraic algorithms is partial evaluation. In
this section we discuss how to implement partial evaluation on a
\index{domain~specific~language}\emph{domain specific language}
(\index{DSL@see{domain~specific~language}}DSL) similar to straight
line programs.

If we want the linearity inference of the previous section to work, we
cannot use standard straight line programs. We shall instead use a
functional language, nicknamed
\index{transAL@see{transposable~Algebraic~Language}}\tAL{} (the
\index{transposable~Algebraic~Language}transposable Algebraic
Language).

\paragraph{\tAL{}}
\label{sec:ta}
We informally describe \tAL{}: giving formal grammar and semantics
would be useless. We shall write algebraic variables in upper case,
and non-algebraic variables and constants in lower case.

For simplicity, the only algebraic instructions in \tAL{} are
\begin{align}
  A &\la B + C
  \text{,}\\
  A &\la B * a
  \text{,}\\
  A &\la B * C
  \text{.}
\end{align}
It is straightforward to generalize to arbitrary algebraic
instructions, including division (in a field). \tAL{} also contains
arbitrary expressions involving non-algebraic variables.

Function calls are written
\begin{equation}
  \label{eq:58}
  A,\ldots,B;x,\ldots,y \la f(C, \ldots, D; t, \ldots, z)
  \text{;}
\end{equation}
they can be recursive. Functions are defined using the $\proc$ and
$\return$ keywords
\begin{equation}
  \label{eq:60}
  \begin{aligned}
    &\proc f (A,\ldots,B;x,\ldots,y)\\
    &\quad\ldots\\
    &\return C,\ldots,D;t,\ldots,z\text{.}
  \end{aligned}
\end{equation}

If statements are the only real difference with the usual imperative
style of writing algebraic algorithms. They are typed and are written
using the $\talif$, $\talelse$ and $\return$ keywords
\begin{equation}
  \label{eq:73}
  \begin{aligned}
    &A, \ldots, B;x,\ldots, y \la \talif (z)\\
    &\quad\cdots\\
    &\return C, \ldots, D;t,\ldots,u\talelse\\
    &\quad\cdots\\
    &\return E, \ldots, F;v,\ldots,w\text{.}
  \end{aligned}
\end{equation}
The scope of variables is local to the if-else-return block.

For simplicity, we do not allow arbitrary variable names to be used
twice on the left of an assignment.

Here is an example \tAL{} program that multiplies an element $A$ by a
scalar $n\in\Z$:
\begin{equation}
  \label{eq:tALprog}
  \begin{aligned}
    &\proc f(A; n)\\[-1ex]
    &\qquad B \la \talif (n == 0)\\[-1ex]
    &\qquad\qquad C \la \text{zero}()\\[-1ex]
    &\qquad \return C \talelse\\[-1ex]
    &\qquad\qquad n' \la n - 1\\[-1ex]
    &\qquad\qquad D \la f(A; n').\\[-1ex]
    &\qquad\qquad E \la A + D\\[-1ex]
    &\qquad \return E\\[-1ex]
    &\return B\text{.}
  \end{aligned}
\end{equation}

A type inference as in the previous section gives types to \tAL{}
variables, in particular we are interested in the types $\ell$ and
$s$. When we need to make clear what the type of a variable is, we use
the notation $A::\ell$.

\paragraph{Partial evaluation}
\label{sec:partial-evaluation}
The partial evaluation at a point $p\in\pspace$ is done in two steps:
first we evaluate all the statements depending from $p$, then we strip
those statements off the partially evaluated program. Let us explain
this through an example. Consider the program
\begin{equation}
  \label{eq:77}
  \begin{aligned}
    &\proc f(A,B;m)\\[-1ex]
    &\qquad C,n \la \talif (m\le 0)\\[-1ex]
    &\qquad \return A,n \talelse\\[-1ex]
    &\qquad\qquad o\la m-1\\[-1ex]
    &\qquad\qquad D,p \la f(A,B;o)\\[-1ex]
    &\qquad\qquad q\la p + 1\\[-1ex]
    &\qquad\qquad E \la D * B\\[-1ex]
    &\qquad \return E,q\\[-1ex] &\return C,n
  \end{aligned}
\end{equation}
that computes $AB^m$, and also outputs $m$ (after some silly
computation).

The only valid linearization of this algorithm is obtained by fixing
$B$ and $m$. We define $f(\bullet,B;m)$ as the program
\begin{equation}
  \begin{aligned}
   &\proc f(\bullet,B;m)\\[-1ex]
   &\qquad n \la \talif (m \le 0)\\[-1ex]
   &\qquad \return n \talelse\\[-1ex]
   &\qquad\qquad o \la m-1\\[-1ex]
   &\qquad\qquad p \la f(\bullet,B;o)\\[-1ex]
   &\qquad\qquad q \la p + 1\\[-1ex]
   &\qquad \return q\\[-1ex]
   &\return n
   \text{,}
  \end{aligned}
\end{equation}
and we define by $\mathcal{T}(f(\bullet,B;m))$ its trace, i.e. the
list of the values taken by the variables appearing in it and in the
called functions.

Then we define the partial evaluation $f_{B,m}$ as 
\begin{equation}
  \begin{aligned}
    &\proc f_{B,m}(A)\\[-1ex]
    &\qquad C \la \talif (m\le 0)\\[-1ex]
    &\qquad \return A \talelse\\[-1ex]
    &\qquad\qquad D \la f_{B,o}(A)\\[-1ex]
    &\qquad\qquad E \la D * B\\[-1ex]
    &\qquad \return E\\[-1ex]
    &\return C\text{.}
  \end{aligned}
\end{equation}
Observe that in order to compute its result, $f_{B,m}$ must know the
value of the variable $o$, so that it can make the call to
$f_{B,o}$. This value can be found in
$\mathcal{T}(f(\bullet,B;m))$. Also observe that
$\mathcal{T}(f(\bullet,B;o))$ is contained in
$\mathcal{T}(f(\bullet,B;m))$, thus one single trace is enough to
compute a partial evaluation, even if the code contains function
calls.

Now $f_{B,m}$ is an algebraic program, thus it can be transposed using
the techniques of Section~\ref{sec:stra-line-progr}. The result is
\begin{equation}
  \begin{aligned}
    &\proc \dual{f}_{B,m}(C)\\[-1ex]
    &\qquad C \la \talif (m\le 0)\\[-1ex]
    &\qquad \return C \talelse\\[-1ex]
    &\qquad\qquad D \la C * B\\[-1ex]
    &\qquad\qquad A \la \dual{f}_{B,o}(D)\\[-1ex]
    &\qquad \return A\\[-1ex]
    &\return C\text{.}
  \end{aligned}
\end{equation}
Thus the full transposition of $f(A,B;m)$ can be obtained by
concatenating $f(\bullet,B;m)$ and $\dual{f}_{B,m}$ (and giving the
full trace of the first to the second).




% Local Variables:
% mode:flyspell
% ispell-local-dictionary:"american"
% mode:TeX-PDF
% mode:reftex
% TeX-master: "../these"
% End:
%
