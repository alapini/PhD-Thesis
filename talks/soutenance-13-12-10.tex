\documentclass[10pt,usepdftitle=false]{beamer}

\usepackage[american]{babel}
\usepackage[utf8]{inputenc}
%\usepackage{soul}
%\usepackage{amsmath}
%\usepackage{amssymb}
\usepackage{textcomp}
\usepackage{listings}
\lstset{
  language=haskell,
  upquote=true,
  basicstyle=\ttfamily,          % print whole listing in typewriter
  keywordstyle=\color{blue}\bfseries, % bold blue keywords
  %identifierstyle=,           % nothing happens
  commentstyle=\color{green}, % green comments
  stringstyle=\color{red},      % typewriter type for strings
  showstringspaces=false     % no special string spaces
}
\usepackage[all]{xy}
\usepackage{tikz}
%\usetikzlibrary{arrows,shapes,automata}
\usepackage{graphicx}
\usepackage[bibstyle=beamer,citestyle=authoryear-comp,doi=false,isbn=false,eprint=false,maxnames=10]{biblatex}
\bibliography{../defeo}
\usepackage{../mysymbols}
\usepackage{array}

\mode<presentation>{%
  \usetheme{these}
}

\title[Fast Algorithms for Towers of Finite Fields and Isogenies]{
  \def\svgwidth{2.63ex}
  \def\exclfont{\scriptsize\rmfamily}
  \input{\artdir/bigescargot-excl}~~~Fast Algorithms\\
  \normalsize\textcolor{black}{for Towers of Finite Fields\\and Isogenies}}
\hypersetup{pdftitle={Fast Algorithms for Towers of Finite Fields and Isogenies},pdfauthor={Luca De Feo}}
\author{Luca~De~Feo}
\institute[LIX \& INRIA Saclay]{LIX, École Polytechnique \& INRIA Saclay, Projet TANC}
\date[December 13, 2010]{December 13, 2010\\École Polytechnique, Palaiseau}


\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Outline}
    \tableofcontents[currentsection]
  \end{frame}
}


\begin{document}

{\setbeamertemplate{footline}[these theme title]
\begin{frame}
  \titlepage
\end{frame}
}

%%
%%

\section{Introduction}

\begin{frame}
  \frametitle{The Discrete Logarithm Problem}
  
  \begin{columns}
    \begin{column}{0.4\textwidth}
      \begin{tikzpicture}
        \begin{scope}
          \foreach \alpha in {0,...,4} {
            \filldraw (-65-25*\alpha:2) circle (2pt);
          }
          \foreach \alpha in {0,...,3} {
            \draw[->] (-65-25*\alpha:2) arc (-65-25*\alpha:-85-25*\alpha:2);
            \draw (-90-25*\alpha:2.3) node {$g^\alpha$};
          }
          \draw (-65:2.3) node {$g^{n-1}$};
          \draw[densely dotted,gray] (-65:2) arc (-65:195:2);
          \draw (0,0) node {\Large $G=\langle g\rangle$};
        \end{scope}
        
        \begin{uncoverenv}<2->
          \begin{scope}[yshift=-3cm]
            \foreach \alpha in {0,...,4} {
              \filldraw (-65-25*\alpha:2) circle (2pt);
            }
            \foreach \alpha in {0,...,3} {
              \draw[->] (-65-25*\alpha:2) arc (-65-25*\alpha:-85-25*\alpha:2);
              \draw (-90-25*\alpha:2.3) node {$\alpha$};
            }
            \draw (-65:2.3) node {$n-1$};
            \draw[densely dotted,gray] (-65:2) arc (-65:48:2);
            \draw[densely dotted,gray] (132:2) arc (132:195:2);
            \draw (0,-0.5) node {\Large $\Z/n\Z$};
          \end{scope}
        \end{uncoverenv}
        
        \begin{uncoverenv}<3->
          \foreach \alpha in {0,...,4}
          \usebeamercolor[fg]{alerted text}
          \draw[dashed] (-65-25*\alpha:2) -- ++(0,-3cm);
        \end{uncoverenv}
      \end{tikzpicture}
    \end{column}
    \begin{column}{0.6\textwidth}
      \begin{block}{Exponentiation in a cyclic group}
        Let $G=\langle g\rangle$ be a cyclic group of order $n$.
        Define
        \begin{align*}
          \exp_g : \Z/n\Z &\ra G\text{,}\\
          x&\mapsto g^x\text{.}
        \end{align*}
      \end{block}

      \begin{block}<2->{Discrete logarithm} $\exp_g$ is an
        isomorphism. Its inverse is called \emph{discrete logarithm}.
        \begin{align*}
          \log_g : G &\ra \Z/n\Z\text{,}\\
          g^x&\mapsto x\text{.}
        \end{align*}

        \begin{uncoverenv}<3-> Computing it is called the
          \alert{Discrete Logarithm Problem} (DLP) of $G$.
        \end{uncoverenv}
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

%%

\begin{frame}
  \frametitle{Elliptic curve cryptography}

  \vspace{-1mm}

  \begin{columns}
    \begin{column}{0.4\textwidth}
      \includegraphics[width=\textwidth]{../isogeny/ec-add.pdf}
    \end{column}
    \begin{column}{0.55\textwidth}
      \begin{block}{Elliptic curve (Weierstrass form)}
        \[E : y^2 = x^3 + ax + b\text{;}\]
      
        The set of points of an elliptic curve is endowed with a group
        law via the chord-and-tangent law.
      \end{block}
    
      \begin{block}{}
        \emph{Hasse bound:} $\card{E(\F_q)} \sim q$.
      \end{block}
    \end{column}
  \end{columns}

  \begin{center}
    \begin{tabular}{l | l | l}
      &\emph{\textbf{Finite field crypto}} & \emph{\textbf{Elliptic curve crypto}}\\
      \hline
      \emph{Group} & $\F_q^\ast$ & $E(\F_q)$\\
      \emph{Protocols} & El Gamal, DSA, \dots & ECDH, ECDSA, ECMQV, \dots\\
      \emph{Key sizes}\footnote{\url{http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57-Part1-revised2_Mar08-2007.pdf}}  & 1024, 2048, 3072 & 160, 225, 256 \\
    \end{tabular}
  \end{center}

\end{frame}

%%

\begin{frame}
  \frametitle{Group law and scalar multiplication}
  
  \begin{columns}
    \begin{column}{0.3\textwidth}
      \includegraphics[width=\textwidth]{../isogeny/ec-add.pdf}
    \end{column}
    \begin{column}{0.55\textwidth}
      \begin{gather*}
        y^2 = x^3 + ax + b\\
        P = (x_0, y_0), Q = (x_1, y_1)\\
        \lambda = \frac{y_1 - y_0}{x_1 - x_0}\\
        P+Q = (\lambda^2 - x_0 - x_1, (x_0 - x_2)\lambda - y_0)
      \end{gather*}
    \end{column}
  \end{columns}

  {\large
    \begin{description}
    \item[\emph{Multiplication:}] $[m]P = \overbrace{P + P + \cdots + P}^{\text{$m$ times}}$
    \item[\emph{$m$-torsion:}] $E[m] = \{P\in E | [m]P=\0\} \isom (\Z/m\Z)^2$
    \end{description}}
  
  \[[m](x,y) = \left(\frac{\psi_m(x,y)}{\phi_m^2(x,y)}, \frac{\omega_m(x,y)}{\psi_m^3(x,y)}\right)\]
  
  \emph{Division polynomials:} $\phi_m$ can be computed with $O(\log
  m)$ polynomial multiplications, $\deg\phi_m=O(m^2)$.
\end{frame}

%%

\begin{frame}
  \frametitle{Isogenies between elliptic curves}
  
  \vspace{-5mm}

  {\large \[\xymatrix{E\ar[d]_{[m]}\ar[r]^{\I} & E'\ar[dl]^{\hat{\I}}\\E}\]} 
  \emph{\textbf{(Separable) isogeny:}} (separable)
  non-constant rational morphism preserving the identity.
  
  \begin{block}{Properties}
    \begin{itemize}
    \item Isogeny = rational map $\;+\;$ group morphism;
    \item Finite kernel, surjective (in $\clot{\K}$);
    \item \emph{Dual isogeny theorem:} they factor the multiplication map into two pieces.
    \end{itemize}
  \end{block}

  \vspace{-1mm}

  \begin{block}{
	\begin{overprint}
	\onslide<1> Multiplication	
	\onslide<2> Frobenius endomorphism
	\onslide<3> Separable isogeny, odd degree (simplified Weierstrass model)
	\end{overprint}
      }
    \begin{overprint}
      \onslide<1>
      \[\begin{aligned}
	{}[m] : E(\clot{\K}) &\rightarrow E(\clot{\K})\\
	                   P &\mapsto [m]P
      \end{aligned}\]
      $\ker\I = E[m]$.

      \onslide<2>
      \[\begin{aligned}
	\frob : E(\clot{\K}) &\rightarrow E(\clot{\K})\\
	               (x,y) &\mapsto (x^q,y^q)
      \end{aligned}\]
      $\ker\frob = \{\0\}$.

      \onslide<3>
      \[\quad\I(X,Y) = \left(\frac{g(x)}{h^2(x)},
      cy\left(\frac{g(x)}{h^2(x)}\right)'\right)\]
      $\card{\ker\I} \;=\; 2\deg h + 1\;$ odd.
    \end{overprint}
  \end{block}  
\end{frame}

%%

\begin{frame}
  \frametitle{Why compute (large) isogenies over finite fields?}
  
  \begin{block}{SEA algorithm (\cite{schoof85,elkies92,atkin88})}
    \begin{description}
    \item[Hasse bound] \hfill{\large\emph{$\card{E(\F_q)}= q-t+1$}};\hfill\strut
    \item[Schoof] Compute $t$ modulo small primes
      $\ell\;\Leftrightarrow$ compute the action of $\frob_q$ on
      \emph{$E[\ell]\isom(\Z/\ell\Z)^2$};
    \item[Atkin] Determine the order of the roots of $X^2 -tX +q$ by
      factoring the $\ell$-th modular polynomial.
    \item[Elkies] Compute an $\ell$-isogeny $\I$ and the action of
      $\frob_q$ on \emph{$\ker\I\isom\Z/\ell\Z\subset E[\ell]$};
    \end{description}
  \end{block}

  \begin{block}{Other cryptographic applications}
    \begin{itemize}
    \item Tranfer DLPs between curves (\cite{gaudry+hess+smart02,smith09});
    \item Construct new cryptosystems (\cite{teske06,rostovtsev+stolbunov06});
    \item Construct hash functions (\cite{charles+lauter+goren09});
    \item Compute modular polynomials (\cite{sutherland10:modpol});
    \item Compute the endomorphism ring (\cite{kohel,sutherland10:hilbert}).
    \end{itemize}
  \end{block}
\end{frame}

%%
%%

\section{Computing isogenies over finite fields}

\begin{frame}
  \frametitle{Vélu's formulas}
  
  \begin{block}{Compute an isogeny with given kernel (\cite{velu71})}
    Given the kernel $H$, computes $\;\I : E\to E/H\;$ given by
    \begin{align*}
      &\I(\0_E) = \I(\0_{E/H})\text{,}\\
      &\begin{aligned}
        \I(P) = \Biggl(x(P) + \sum_{Q\in H^\ast}x(P+Q) - x(Q),
        y(P) + \sum_{Q\in H^\ast}y(P+Q) - y(Q) \Biggr) \text{.}
      \end{aligned}
    \end{align*}
  \end{block}

  \begin{block}{In practice, given $h(x)$ vanishing on $H$}
    {\footnotesize
      \[
      y^2 = f(x)
      \qquad
      t = \sum_{Q\in H^\ast} f'(Q)\text{,}
      \quad
      u = \sum_{Q\in H^\ast} 2f(Q)\text{,}
      \quad
      w = u + \sum_{Q\in H^\ast} x(Q)f'(Q)\text{,}\]}
    \[\alert{\I(x,y) = \left(\frac{g(x)}{h(x)}, y\left(\frac{g(x)}{h(x)}\right)'\right)}
    \quad\text{with}\quad
    \frac{g(x)}{h(x)} = x + t\frac{h'(x)}{h(x)} - u\left(\frac{h'(x)}{h(x)}\right)'\]
  \end{block}
\end{frame}

%%

\begin{frame}
  \frametitle{Isogeny computation}
  By Vélu's formulas: $\I(x,y) = \left(\frac{g(x)}{h(x)},
    y\left(\frac{g(x)}{h(x)}\right)'\right)$, hence
  \[(x^3 + ax + b){\left(\frac{g(x)}{h(x)}\right)'}^2 =
  \left(\frac{g(x)}{h(x)}\right)^3 + a'\frac{g(x)}{h(x)} + b'\]
  
  \begin{block}{\textbf{Algorithms:} Given $E, E', \ell$, compute $\I:E\to E'$}
    \begin{itemize}
    \item \emph{\cite{couveignes94}:} Compute morphisms of formal
      groups, look for one that corresponds to an isogeny.
    \item \emph{\cite{couveignes96}:} Interpolate over the
      $p$-torsion, look for a polynomial that corresponds to an
      isogeny.
    \item \emph{\cite{lercier96}:} (only for $p=2$) solve a linear
      system.
    \item \emph{BMSS
        algorithm \parencite{bostan+morain+salvy+schost08}:} Find a
      power series solution to the differential equation, then
      reconstruct the isogeny.
    \item \emph{\cite{lercier+sirvent08}:} Lift $E$ and $E'$ in the
      $p$-adics to avoid divisions by zero, then apply BMSS.
    \end{itemize}
  \end{block}
\end{frame}

%%

\begin{frame}
  \frametitle{Couveignes' algorithm (\cite{couveignes96})}
  
  \begin{center}
    \large
    Given $E, E', \ell$, compute $\I:E\to E'$
  \end{center}

  \begin{center}
    \emph{\textbf{Idea:}} Send $E[p^k]$ over $E'[p^k]$
  \end{center}
  
  \begin{itemize}
  \item Compute the extensions $\U_i/\F_q$ such that $E[p^i]$ is
    defined in $\U_i$;
    \uncover<1-3>{\hfill\emph{\temporal<2>{}{$\tildO(\ell^2)$}{\alert{$\tildO(\Mult(\ell))$}}}}
  \item Pick $\;k\;$ \emph{large enough} ($k\sim\log_p4\ell$);
  \item Compute $\;P$, a generator of $\;E[p^k]$;
    \uncover<1-3>{\hfill\emph{\temporal<2>{}{$\tildO(\ell^2)$}{\alert{$\tildO(\Mult(\ell))$}}}}
  \item Compute $\;P'$, a generator of $\;E'[p^k]$;
    \uncover<1-3>{\hfill\emph{\temporal<2>{}{$\tildO(\ell^2)$}{\alert{$\tildO(\Mult(\ell))$}}}}
  \item Compute the polynomial $\;T\;$ vanishing $\;E[p^k]$;
    \uncover<1-3>{\hfill\emph{\temporal<2>{}{$\tildO(\ell^2)$}{\alert{$\tildO(\Mult(\ell))$}}}}
  \item For $j\in\left(\Z/p^k\Z\right)^\ast$
    \begin{itemize}
      \normalsize
    \item Interpolate $\;A : x(P) \mapsto x([j]P')$;
      \uncover<1-3>{\hfill\emph{\temporal<2>{}{$\tildO(\ell^2)$}{\alert{$\tildO(\Mult(\ell))$}}}}
    \item Reconstruct a rational fraction  $\;\frac{g}{h}\equiv A \bmod T$;
      \uncover<1-3>{\hfill\emph{\alt<1>{}{$\tildO(\Mult(\ell))$}}}
    \end{itemize}
    \alert<4>{Stop when $\frac{g}{h}$ is an isogeny.}
    \uncover<1-3>{\hfill\emph{\alt<1>{}{$\ell$ times on average}}}
  \end{itemize}
\end{frame}

%%

\begin{frame}
  \frametitle{How to recognize an isogeny?}

  \begin{itemize}
    \setlength{\itemsep}{\baselineskip}
  \item \emph{\textbf{Degree:}} $\frac{g}{h}\;$ with $\;\deg g=\ell$, $\;\deg h = \ell-1$;\hfill\alert{$O(1)$}
  \item \emph{\textbf{Square factor:}} $h = \prod_{Q\in H^\ast}(X-
    x(Q)) = f^2\;$ if $\ell$ odd;\hfill\emph{$\tildO(\Mult(\ell))$}
  \item \emph{\textbf{Group action:}} Test with random points;\hfill\emph{$O(\ell)$}
  \item \emph{\textbf{Factor of the $\ell$-division polynomial:}}
    Compute $\phi_\ell\bmod h$.\hfill\emph{$\tildO(\Mult(\ell))$}
  \end{itemize}
\end{frame}

%%

\begin{frame}
  \frametitle{How to recognize an isogeny?}
  
  \[AU_i + TV_i = R_i  \qquad\Leftrightarrow\qquad  A\equiv \frac{R_i}{U_i} \bmod T\]
  \[\ell = 11\]
  \pause
  \begin{center}
  \begin{tabular}{c | c}
    $\deg R_i$ & $\deg U_i$ \\
    $3141592653589793238462643$ & 0 \\
    \pause
    $3141592653589793238462642$ & 1 \\
    \pause
    $3141592653589793238462641$ & $2$ \\
    \pause
    \vdots & \vdots\\
    $3141592653589793238462634$ & $9$ \\
    \pause\pause
    \Huge\alert{$11$} & \Huge\alert{$10$}\\
    \pause
    $10$ & $3141592653589793238462633$\\
    \vdots & \vdots
  \end{tabular}
  \end{center}
\end{frame}

%%

\begin{frame}
  \frametitle{Isogenies of unknown degree}
  
  \begin{itemize}
  \item This pattern is extremely rare.
  \item This is the only phase of Couveignes' algorithm that depends on $\ell$.
  \end{itemize}

  \begin{itemize}
  \item<2-> \large Actually, this does not really depend on $\ell$,
    just on the existence of a \emph{gap}.
  \item<2-> \large If $\ell$ is not known in advance, it is enough to
    look for a \emph{gap}.
  \item<2-> \large Thus, any isogeny of degree $\ll p^k$ can be
    computed with one single run of Couveignes' algorithm.
  \end{itemize}  
\end{frame}

%%

\begin{frame}
  \frametitle{Comparison of isogeny algorithms}
  
  \begin{figure}
    \centering
    \includegraphics[height=0.5\textwidth]{../isogeny/C2-LS}
    \includegraphics[height=0.5\textwidth]{../isogeny/C2-LS2}
    \caption{Comparative timings for \cite{couveignes96} (C2) and
      \cite{lercier+sirvent08} (LS) over various curves. Plot in
      logarithmic scale.}
  \label{fig:comp}
\end{figure}
\end{frame}

\begin{frame}
  \frametitle{Isogenies of unknown degree}

  \begin{itemize}
  \item This variant of \cite{couveignes96} is at the moment the
    fastest (both in theory and in practice) algorithm for this
    task.
  \item We tested two curves over $\F_{2^{161}}$, isogenous of
    unknown degree, taken from \cite{teske06}: proven in 694
    cpu-hours that no isogeny of degree less then $2^{13}$ exists.
  \item Interesting applications for this algorithm are yet to be
    found.
  \end{itemize}
\end{frame}

%%
%%

\section{Artin-Schreier towers}

\begin{frame}<1-2>
  \frametitle{The field of definition of $E[p^k]$}
  
  \begin{columns}
    \begin{column}{0.3\textwidth}
      \begin{overlayarea}{\textwidth}{0.9\textheight}
        \begin{onlyenv}<1>
          \large\[\xymatrix@C=20pt{
            *[r]{\U_k} \ar@{-}[d]^p & E[p^k] \ar@{-->}[l]\\
            *[r]{\U_{k-1}} \ar@{--}[dd] & E[p^{k-1}] \ar@{-->}[l]\\
            \\
            *[r]{\U_2} \ar@{-}[d]^p & E[p^2] \ar@{-->}[l]\\
            *[r]{\U_1} \ar@{-}[d] & E[p] \ar@{-->}[l]\\
            *[r]{\F_q}
          }\]
        \end{onlyenv}
        \begin{onlyenv}<2>
          \Large\[\xymatrix{
            *+[r]{\U_k = \frac{\U_{k-1}[X_k]}{P_{k-1}(X_k)}}\ar@{-}[d]^p\\
            *+[r]{\U_{k-1}} \ar@{--}[dd]\\
            \\
            *+[r]{\U_{1} = \frac{\U_0[X_1]}{P_0(X_1)}} \ar@{-}[d]^p\\
            *+[r]{\U_{0} = \F_q = \frac{\F_p[X_0]}{Q(X_0)}}
          }\]
        \end{onlyenv}
      \end{overlayarea}
    \end{column}
    \begin{column}{0.65\textwidth}
      \begin{block}{$p$-descent (\cite{voloch90})}
        If $\;P_i=(x_i,y_i)\;$ generates $\;E[p^i]$, the solution to
        \begin{align*}
          z^p - z &= \frac{\sqrt[p]{y_i\beta_E(x_i)}}{\sqrt[p-1]{H_E}}\\
          x_{i+1} &= \sqrt[p]{x_i}\\
          y_{i+1} &= \sqrt[p]{y_i}
        \end{align*}
        generates $\;E[p^{i+1}]$ (on an isomorphic curve).
      \end{block}

      \begin{block}<2>{Artin-Schreier Towers over finite fields}
        $\LK/\K$ extension: Artin-Schreier polynomial:
        \vspace{-.5mm}
        \begin{center}
          \large\emph{$X^p - X - \alpha$}
        \end{center}
        \vspace{-.5mm}
        \alert{ANY} separable extension of degree $p$ can be expressed
        this way.
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

%%

\begin{frame}
  \frametitle{Arithmetic in towers of extensions}
  
  \begin{columns}
    \begin{column}{0.3\textwidth}
      \Large\[\xymatrix{
        *+[r]{\U_k = \frac{\U_{k-1}[X_k]}{P_{k-1}(X_k)}}\ar@{-}[d]^p\\
        *+[r]{\U_{k-1}} \ar@{--}[dd]\\
        \\
        *+[r]{\U_{1} = \frac{\U_0[X_1]}{P_0(X_1)}} \ar@{-}[d]^p\\
        *+[r]{\U_{0} = \F_{p^d} = \frac{\F_p[X_0]}{Q(X_0)}}
      }\]
    \end{column}
    \begin{column}{0.65\textwidth}
      \begin{block}{Multiplication}
        \vspace{-\baselineskip}
        \begin{align*}
          \Mult(\U_0) &= O\bigl(\Mult(d)\bigr)\\
          \Mult(\U_1) &= O\bigl(p^2\Mult(d)\bigr)\\
          \Mult(\U_2) &= O\bigl(p^4\Mult(d)\bigr)\\
          &\vdots\\
          \Mult(\U_k) &= O\bigl(p^{2k}\Mult(d)\bigr) \varsupsetneq \tildO(p^kd)
        \end{align*}
        
        Even using Karatsuba or FFT multiplication, we are far from
        optimality.
      \end{block}
      \vspace{-1.5mm}
      \begin{block}{Other operations}
        \begin{itemize}
        \item Exponentiation, Inversion, GCD, all depend upon $\;\Mult(\U_k)$,
        \item The canonical injection $\;\U_{i-1}\ra\U_i$ can be computed in $O(p^i)$.
        \end{itemize}
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

%%

\begin{frame}
  \frametitle{One fast tower, many fast towers!}
  
  \begin{center}
    Fast tower

    \smallskip

    \large$\xymatrix{
      \only<3>{E[p^k]\ar@{-->}[r]} & \only<2->{\U_k \ar@{-}[d]\ar[r]}      & \LK_k \ar@{-}[d]      & \only<2->{\U_k' \ar@{-}[d]\ar[l]}& \only<3>{E[p^k]\ar@{-->}[l]}\\
      &\only<2->{\U_{k-1} \ar@{--}[dd]\ar[r]} & \LK_{k-1} \ar@{--}[dd] & \only<2->{\U_{k-1}' \ar@{--}[dd]\ar[l]}\\
      \\
      &\only<2->{\U_1 \ar@{-}[dr]\ar[r]}     & \LK_1 \ar@{-}[d]      & \only<2->{\U_1' \ar@{-}[dl]\ar[l]}\\
      &                    &\LK_0
    }$
  \end{center}

  \uncover<2->{ \emph{Theorem (\cite{couveignes00}):} There exist an
    isomorphism algorithm that runs in \alert{$O(k^3\Mult(\LK_k))$}
    operations in $\LK_0$.}
\end{frame}

%%

\begin{frame}
  \frametitle{A fast tower}

  \begin{tikzpicture}
    \begin{scope}
      \draw (0,0) node {\Large$\xymatrix{
          *+[r]{\LK_k = \frac{\U_{k-1}[X_k]}{P_{k-1}(X_k)}}\ar@{-}[d]^p\\
          *+[r]{\LK_{k-1}} \ar@{--}[d]\\
          *+[r]{\LK_1 = \frac{\U_0[X_1]}{P_0(X_1)}} \ar@{-}[d]^p\\
          *+[r]{\LK_0 = \F_q = \frac{\F_p[X_0]}{Q(X_0)}} \ar@{-}[d]^d\\
          *+[r]{\F_p}
        }$};
    \end{scope}

    \begin{scope}[xshift=1.8cm]
      \draw (2,1) node {\parbox{3.3cm}{\emph{Idea:} Convert to a univariate basis \alert{over $\F_p$}}};
      \uncover<2->{\draw[<->] (0,0) -- (4,0);}
    \end{scope}
      
    \begin{uncoverenv}<2->
      \begin{scope}[xshift=8cm]
        \draw (0,0) node {\Large$\xymatrix{
            *+[r]{\LK_k = \frac{\F_{k-1}[X_k]}{Q_{k-1}(X_k)}}\ar@{-}[d]^p\\
            *+[r]{\LK_{k-1}} \ar@{--}[d]\\
            *+[r]{\LK_1 = \frac{\F_p[X_1]}{Q_1(X_1)}} \ar@{-}[d]^p\\
            *+[r]{\LK_0 = \F_q = \frac{\F_p[X_0]}{Q(X_0)}} \ar@{-}[d]^d\\
            *+[r]{\F_p}
          }$};
      \end{scope}
    \end{uncoverenv}
  \end{tikzpicture}
\end{frame}

%% 

\begin{frame}
  \frametitle{A fast tower}

  \vspace{-2mm}

  \begin{columns}
    \begin{column}{0.1\textwidth}
      \Large\[\xymatrix{
        \LK_k \ar@{-}[d]^p\\
        \LK_{k-1} \ar@{--}[dd]\\
        \\
        \LK_1 \ar@{-}[d]^p\\
        \LK_0 \ar@{-}[d]^d\\
        \F_p
      }\]
    \end{column}
    \begin{column}{0.85\textwidth}
      \begin{block}{Our construction (inspired by \cite{cantor89})}
        Let $\;x_0 = X_0\;$ such that
        $\;\Tr_{\LK_0/\F_p}(x_0) \ne 0$, let
        \begin{align*}
          P_0 \quad&=\quad X^p - X - x_0\\
          P_i \quad&=\quad X^p - X - x_i^{2p-1}
        \end{align*}
        with $\;x_{i+1}\;$ a root of $\;P_i\;$ in $\;\LK_{i+1}$.

        \alert{This tower is such that $x_i$ generates $\LK_i/\F_p$.}
      \end{block}

      \begin{block}{Two bases to represent $\LK_k$}
        \begin{itemize}
        \item Univariate: \hfill\emph{$\LK_k=\F_p[Z]/Q_k(Z)$}\hfill
        \item Multivariate: \hfill\emph{$\LK_k=\F_p[X_0,X_1,\ldots,X_k]/(Q,P_0,\ldots,P_{k-1})$}\hfill
        \end{itemize}
        \alert{A fast change of basis is the key to fast arithmetic:}
        \begin{itemize}
        \item Multiplication is faster in \emph{univariate};
        \item Embeddings are faster in \emph{multivariate}.
        \end{itemize}
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

%%

% \begin{frame}
%   \frametitle{Fast tower example}
  
% \end{frame}

%%

\begin{frame}
  \frametitle{Change of basis}

  \begin{block}{Univariate $\ra$ multivariate}
    Recursive algorithm: given $\;a(Z)\in\F_p[Z]/Q_k(Z)$
    \begin{itemize}
    \item Split $a$ in $p$ parts;
    \item convert recursively to multivariate;
    \item recombine using Horner's rule.
    \end{itemize}
    Simple and fast: \emph{$\;O(\Mult(\ell) + \ell\log^2\ell)$}!
  \end{block}

  \begin{block}{Multivariate $\ra$ univariate}
    By \textit{trace formulas} (\cite{rouiller99}):
      \[
      a(Z) = \frac{A(Z)}{Q_k'(Z)}
      \qquad\text{where}\qquad
      A(T) = Q_k(T)\alert<2>{\sum_{i\ge 0}\frac{\Tr aZ^i}{T^{i+1}}}
      \text{.}\]
    \begin{itemize}
    \item Compute the \textit{trace form} $\;\Tr\;$ and the form
      $\;a\cdot\Tr : x\mapsto \Tr ax$;
    \item \alert<2>{compute $\;\sum_{i\ge 0}\frac{\Tr aZ^i}{T^{i+1}}$}, deduce $\;a(Z)$.
    \end{itemize}
  \end{block}
\end{frame}

%%

\begin{frame}
  \frametitle{Duality (\cite{shoup95,shoup99,bostan+salvy+schost03})}

  \vspace{-6mm}

  \begin{columns}[b]
    \begin{column}{0.5\textwidth}
      \begin{center}
        \textbf{Polynomial evaluation}$:k[T]\ra\K/k$
        \[g\mapsto g(\sigma)\]
      \end{center}
    \end{column}
    \begin{column}{0.5\textwidth}
      \begin{center}
        \textbf{Power projection}$:(\K/k)^\ast\ra k[T]^\ast$
        \[\ell \mapsto \sum_{i>0} \frac{\ell(\sigma^i)}{T^i}\]
      \end{center}
    \end{column}
  \end{columns}

  \begin{block}{Univariate $\ra$ multivariate $=$ Polynomial evaluation}
    If $Z \mapsto \zeta\;$ (with $\zeta\in\U_k$ written on the
    multivariate basis):
    \[a(Z) = a_dZ^d + \cdots + a_1Z + a_0 \quad\mapsto\quad a_d\zeta^d + \cdots + a_1\zeta + a_0 =a(\zeta)\text{.}\]
  \end{block}

  \begin{block}{$($Univariate $\ra$ bivariate$)^\ast=$ Power projection}
    \begin{align*}
      \Tr &\quad\mapsto\quad \sum_{i\ge0}\frac{\Tr\zeta^i}{T^i}\text{,}\\
      a\cdot\Tr &\quad\mapsto\quad \sum_{i\ge0}\frac{\Tr a\zeta^i}{T^i}\text{.}
    \end{align*}
  \end{block}
\end{frame}

%%

\begin{frame}
  \frametitle{The transposition principle}

  \large
  
  \begin{theorem}
    ``Let $\pspace$ be an arbitrary set. To any $R$-algebraic
    algorithm $A$ computing a family of linear functions $(f_p:M\ra
    N)_{p\in\pspace}$ corresponds an $R$-algebraic algorithm
    $\dual{A}$ computing the \emph{dual family}
    $(\dual{f}_p:\dual{N}\ra\dual{M})_{p\in\pspace}$. The algebraic
    time and space complexities of $\dual{A}$ are bounded by the time
    complexity of $A$.''
  \end{theorem}
  
\end{frame}

%%

\begin{frame}
  \frametitle{Change of basis}

  \begin{block}{Univariate $\ra$ multivariate}
    Recursive algorithm: given $\;a(Z)\in\F_p[Z]/Q_k(Z)$
    \begin{itemize}
    \item Split $a$ in $p$ parts;
    \item convert recursively to multivariate;
    \item recombine using Horner's rule.
    \end{itemize}
    Simple and fast: \emph{$\;O(\Mult(\ell) + \ell\log^2\ell)$}
  \end{block}

  \vspace{-1mm}

  \begin{block}{Multivariate $\ra$ univariate\hfill\alert{$\;O(\Mult(\ell) + \ell\log^2\ell)$}}
    By \textit{trace formulas} (\cite{rouiller99}):
    \[
    a(Z) = \frac{A(Z)}{Q_k'(Z)}
    \qquad\text{where}\qquad
    A(T) = Q_k(T)\sum_{i\ge 0}\frac{\Tr aZ^i}{T^{i+1}}
    \text{.}\]
    \vspace{-4mm}
    \begin{itemize}
    \item Compute the \textit{trace form} $\;\Tr\;$ and the form
      $\;a\cdot\Tr : x\mapsto \Tr ax$;
    \item compute $\;\sum_{i\ge 0}\frac{\Tr aZ^i}{T^{i+1}}$
      \alert{using a transposed univariate $\ra$ multivariate};
    \item deduce $\;a(Z)$.
    \end{itemize}
  \end{block}
\end{frame}


% %%
% %%

% \section{The transposition principle}

% \begin{frame}
%   \frametitle{The transposition principle}

%   \begin{quote}
%     \large ``Let $\pspace$ be an arbitrary set. To any $R$-algebraic
%     algorithm $A$ computing a family of linear functions $(f_p:M\ra
%     N)_{p\in\pspace}$ corresponds an $R$-algebraic algorithm
%     $\dual{A}$ computing the \emph{dual family}
%     $(\dual{f}_p:\dual{N}\ra\dual{M})_{p\in\pspace}$. The algebraic
%     time and space complexities of $\dual{A}$ are bounded by the time
%     complexity of $A$.''
%   \end{quote}
  
% \end{frame}

% %%

% \begin{frame}
%   \frametitle{Transposition of arithmetic circuits}

%   Plus dynamique !!

%   \begin{columns}
%     \begin{column}{0.6\textwidth}
%       \begin{center}
%         Arithmetic circuits are like diagrams enriched with a
%         \emph{product}. In particular they can be \emph{transposed}:
%       \end{center}

%       \begin{center}
%       \begin{tikzpicture}
%         \tikzstyle{node}=[circle,thick,draw=black,minimum size=4mm]
%         \tikzstyle{arg}=[rectangle,thin,draw=black,minimum size=4mm]
        
%         \begin{scope}
%           \node[arg](in1){$x_1$};
%           \node[arg,right of=in1](in2){$x_2$};
%           \node[arg,right of=in2](in3){$x_3$};
          
%           \node[node,below of=in1](plus1){$+$};
%           \node[node,right of=plus1](H){$\hub$};

%           \node[node,below of=plus1](plus2){$+$};
%           \node[node,right of=plus2](times){$\rmul{2}$};

%           \node[arg,below of=plus2,xshift=6mm](out1){$y_1$};
%           \node[arg,right of=out1](out2){$y_2$};

%           \path[->]
%           (in1) edge (plus1)
%           (in2) edge (H)
%           (in3) edge (out2)
%           (H) edge (plus1)
%           (H) edge (times)
%           (plus1) edge (plus2)
%           (times) edge (plus2)
%           (plus2) edge (out1);
%         \end{scope}

%         \begin{uncoverenv}<2->
%         \begin{scope}[xshift=3cm, yshift=-0.17\textheight]
%           \node(x){\Huge $\leftrightarrow$};
%         \end{scope}

%         \begin{scope}[xshift=4.2cm]
%           \node[arg](in1){$\dual{x_1}$};
%           \node[arg,right of=in1](in2){$\dual{x_2}$};
%           \node[arg,right of=in2](in3){$\dual{x_3}$};
      
%           \node[node,below of=in1](plus1){\alt<3>{$\hub$}{$+$}};
%           \node[node,right of=plus1](H){\alt<3>{$+$}{$\hub$}};
          
%           \node[node,below of=plus1](plus2){\alt<3>{$\hub$}{$+$}};
%           \node[node,right of=plus2](times){$\rmul{2}$};
          
%           \node[arg,below of=plus2,xshift=6mm](out1){$\dual{y_1}$};
%           \node[arg,right of=out1](out2){$\dual{y_2}$};
          
%           \path[<-]
%           (in1) edge (plus1)
%           (in2) edge (H)
%           (in3) edge (out2)
%           (H) edge (plus1)
%           (H) edge (times) 
%           (plus1) edge (plus2)
%           (times) edge (plus2)
%           (plus2) edge (out1);
%         \end{scope}
%         \end{uncoverenv}
%       \end{tikzpicture}
%       \end{center}

%       \begin{center}
%         \uncover<3>{This can be made precise using category theory.}
%       \end{center}
%     \end{column}
%     \begin{column}{0.4\textwidth}
%       \begin{align*}
%         y_1 &= x_1 + 3x_2\\
%         y_2 &= x_3
%       \end{align*}
      
%       \Large
%       \begin{gather*}
%         \begin{pmatrix}
%           1 & 3 & 0\\
%           0 & 0 & 1
%         \end{pmatrix}\\
%         \uncover<2->{\updownarrow}\\
%         \uncover<2->{\begin{pmatrix}
%           1 & 0\\
%           3 & 0\\
%           0 & 1\\
%         \end{pmatrix}}
%       \end{gather*}
%     \end{column}
%   \end{columns}
% \end{frame}

% %%

%%

% \begin{frame}
%   \frametitle{Multilinearity}

%   \begin{center}
%     \large
%     Does it make sense to transpose $\;c:=a*b$?
%   \end{center}

%   \begin{center}
%     \begin{tikzpicture}
%       \tikzstyle{node}=[circle,thick,draw=black,minimum size=4mm]
%       \tikzstyle{arg}=[rectangle,thin,draw=black,minimum size=4mm]
%       \tikzstyle{nodeg}=[circle,thick,draw=gray,minimum size=4mm]
%       \tikzstyle{argg}=[rectangle,thin,draw=gray,minimum size=4mm]
      
%       \begin{scope}
%         \node[arg](in1){$x_1$};
%         \node[arg,right of=in1](in2){$x_2$};
%         \node[arg,right of=in2](in3){$x_3$};
%         \node[node,below of=in1,xshift=5mm](times1){$*$};
%         \node[node,below of=times1,xshift=5mm](times2){$*$};
%         \node[arg,below of=times2](out){$y_1$};
        
%         \path[->]
%         (in1) edge (times1)
%         (in2) edge (times1)
%         (times1) edge (times2)
%         (in3) edge (times2)
%         (times2) edge (out);
%       \end{scope}
      
%       \begin{scope}[xshift=4cm]
%         \node[argg](in1){\color{gray}{$x_1$}};
%         \node[arg,right of=in1](in2){$x_2$};
%         \node[argg,right of=in2](in3){\color{gray}{$x_3$}};
%         \node[node,below of=in1,xshift=5mm](times1){$*_{x_1}$};
%         \node[node,below of=times1,xshift=5mm](times2){$*_{x_3}$};
%         \node[arg,below of=times2](out){$y_1$};
        
%         \path[->]
%         (in2) edge (times1)
%         (times1) edge (times2)
%         (times2) edge (out);
        
%         \path[->,draw=gray,dashed]
%         (in1) edge (times1)
%         (in3) edge (times2);
%       \end{scope}
      
%       \begin{scope}[xshift=8cm]
%         \node[arg](in1){$x_3$};
%         \node[arg,right of=in1](in2){$y_1^\ast$};
%         \node[arg,right of=in2](in3){$x_1$};
%         \node[node,below of=in1,xshift=5mm](times1){$*$};
%         \node[node,below of=times1,xshift=5mm](times2){$*$};
%         \node[arg,below of=times2](out){$x_2^\ast$};

%         \path[->]
%         (in2) edge (times1)
%         (times1) edge (times2)
%         (times2) edge (out)
%         (in3) edge (times2)
%         (in1) edge (times1);
%       \end{scope}
%     \end{tikzpicture}  
%   \end{center}

%   \begin{itemize}
%   \item Most applications require to \emph{linearize} a multi-linear
%     program.
%   \item Can we automatically deduce any possible linearisation of a
%     program?
%   \item \alert{Type inference systems can help us}
%   \end{itemize}
% \end{frame}

% %%

% \begin{frame}[fragile]
%   \frametitle{Linearity inference}

%   \begin{center}
%     Suppose given a type \lstinline{R} implementing a ring. We want to
%     define types \alert{\lstinline{L}} (for \emph{linear}) and
%     \alert{\lstinline{S}} (for \emph{scalar}) such that the following
%       equations hold
%   \end{center}
  
%   \begin{columns}
%     \begin{column}{0.5\textwidth}
%   \begin{semiverbatim}
%     plus :: L -> L -> L
%     plus :: S -> S -> S
%   \end{semiverbatim}
%     \end{column}
%     \begin{column}{0.5\textwidth}
%       \uncover<2>{\[\forall
%         \alpha\in\{L,S\}.\alpha\ra\alpha\ra\alpha\]}
%     \end{column}
%   \end{columns}
  
%   \begin{columns}[c]
%     \begin{column}{0.5\textwidth}
%   \begin{semiverbatim}
%     times :: L -> S -> L
%     \alt<2>{\st{times :: S {} -> L {} -> L}}{times :: S -> L -> L}
%     times :: S -> S -> S
%   \end{semiverbatim}
%     \end{column}
%     \begin{column}{0.5\textwidth}
%       \uncover<2>{\[\forall
%         \alpha\in\{L,S\}.\alpha\ra S\ra\alpha\]}
%     \end{column}
%   \end{columns}

%   \begin{columns}
%     \begin{column}{0.5\textwidth}
%   \begin{semiverbatim}
%     zero :: L
%     zero :: S
%   \end{semiverbatim}
%     \end{column}
%     \begin{column}{0.5\textwidth}
%       \uncover<2>{\[\forall
%         \alpha\in\{L,S\}.\alpha\]}      
%     \end{column}
%   \end{columns}

%   \begin{columns}
%     \begin{column}{0.5\textwidth}
%   \begin{semiverbatim}
%     one :: S
%   \end{semiverbatim}
%     \end{column}
%     \begin{column}{0.5\textwidth}
%     \end{column}
%   \end{columns}
% \end{frame}  

% \begin{frame}[fragile]
%   \frametitle{Linearity inference}
  
%   \begin{center}
%     The solution in Haskell
%   \end{center}

%   \begin{lstlisting}
%     data L = L R
%     data S = S R
    
%     class Ring r where
%       zero :: r
%       (<+>) :: r -> r -> r
%       neg :: r -> r
%       (<*>) :: r -> S -> r

%     one = S oneR
%     (S a) == (S b) = a == b
%   \end{lstlisting}

%   \begin{center}
%     To treat \alert{\lstinline{times :: S -> L -> L}}, we extend the
%     Hindley-Milner type inference to handle lists of acceptable
%     unifications.
%   \end{center}
% \end{frame}

%%

% \begin{frame}
%   \frametitle{\tALpy{}}
  
%   \begin{block}{We are implementing}
%     A Python-like ad-hoc language, compiled/interpreted in Python,
%     featuring:
%     \begin{itemize}
%     \item Algebraic constructs (Rings, Modules, Fields, \ldots);
%     \item Transposition of multilinear/recursive code;
%     \item Parameterizable linearity inference (including commutative
%       multiplication);
%     \item Algebraic complexity preserving;
%     \item Easily used on top of Computer Algebra Systems that have a
%       Python interface;
%     \item Other Computer Algebra Systems will be able to work with it
%       as we will add more languages to the output of the compiler
%       (OCaml and Haskell look easy, C is somewhat harder).
%     \end{itemize}
%   \end{block}

%   \begin{center}
%     \url{http://transalpyne.gforge.inria.fr/}
%   \end{center}
% \end{frame}

% %%

%%
%%

\section{Perspectives}

\begin{frame}
  \frametitle{Automatic transposition}

  \begin{itemize}
  \item Algorithms are hard to transpose, transposed algorithms are
    hard or impossible to understand;
  \item How to be confident that a transposed algorithm is well
    implemented if no one understands it?
  \item When proving programs with a proof assistant, why should we do
    the work twice?
  \end{itemize}

  \begin{block}{\texttt{transalpyne}}
    A Python-like ad-hoc language for automatic transposition,
    compiled/interpreted in Python.

    \begin{center}
      \url{http://transalpyne.gforge.inria.fr/}
    \end{center}
  \end{block}

  \begin{block}{The future of \texttt{transalpyne}}
    \begin{itemize}
    \item Finish the implementation, add more output languages.
    \item Integration in a Computer Algebra System (Sage?
      Mathemagix?).
    \item Development in a dependently typed system (Coq? Agda?).
    \end{itemize}
  \end{block}
\end{frame}

%%

\begin{frame}
  \frametitle{Perspectives on isogenies and Artin-Schreier towers}
  
  \begin{block}{Implementations}
    \begin{itemize}
    \item \emph{FAAST (Fast Arithmetics in Artin-Schreier towers):}
      \texttt{C++} with NTL implementation released under GPL:
      \url{http://www.lix.polytechnique.fr/~defeo/FAAST/}
    \item With F. Morain, writing a \texttt{C++} library for isogeny
      over finite fields.
    \end{itemize}
  \end{block}

  \begin{block}{Perspectives on isogenies}
    \begin{itemize}
    \item All known algorithms to compute isogenies have suboptimal
      complexity $\Omega(\ell^2)$.
    \item Are there models, where algorithms \textit{à la} BMSS and
      \cite{lercier+sirvent08} may be faster?
    \item Couveignes' first isogeny algorithm (\cite{couveignes94}) is
      very similar to \cite{couveignes96} and may be modified in the
      same way. There is some hope that it may be faster in practice,
      because of the simpler arithmetic operations needed.
    \item Generalize Couveignes' algorithms to genus $2$?
    \end{itemize}
  \end{block}
\end{frame}
\end{document}


% Local Variables:
% mode:flyspell
% ispell-local-dictionary:"american"
% mode:TeX-PDF
% mode:reftex
% End:
%
% LocalWords:  Isogeny abelian isogenies hyperelliptic supersingular Frobenius
% LocalWords:  isogenous
