\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction (English)}



% In this thesis we apply techniques from computer algebra and language
% theory to speed up the elementary operations in some specific towers
% of finite fields. We apply our construction to the problem of
% computing isogenies between elliptic curves and obtain faster (both
% asymptotically and in practice) variants of Couveignes' algorithm.

% After some preliminaries, we introduce in Part II one of our main
% tools: transposition of linear programs. Previously, Bostan, Schost
% and Lecerf had shown that transposition of programs is possible,
% without losses in time and space complexity, in a slightly generalized
% straight-line-program model. We generalize their construction and
% devise a fully featured functional language together with an algorithm
% to transpose programs written in it. Our new transposition is as
% efficient as theirs on programs that fit into their model, but it also
% permits to treat more generic programs with a minor loss in space
% complexity. We also describe the implementation of a compiler
% materializing our ideas.

% In Part III, we combine our transposition method with well known
% techniques coming from computer algebra and elimination theory, then
% we show some new results on towers of Artin-Schreier extensions over
% finite fields. This allows us to design a complete set of algorithms
% to perform the most common arithmetic operations on Artin-Schreier
% towers in quasi-optimal time. We implemented all our algorithms in a
% software package that we describe at the end of this part.

% Finally, Part IV discusses the problem of isogeny computation. We
% apply our techniques to a fast variant of Couveignes' algorithm that
% we had obtained in our Masters thesis, and make comparisons to other
% algorithms to compute isogenies.



% Dans cette thèse nous appliquons des techniques provenant du calcul
% formel et de la théorie des langages afin d'améliorer les operations
% élémentaires dans certaines tours de corps finis. Nous appliquons
% notre constructions au problème du calcul d'isogénies entre courbes
% elliptiques et obtenons une variante plus rapide (à la fois en théorie
% et en pratique) de l'algorithme de Couveignes.

% Après avoir introduit les notions de base, nous présentons dans la
% Partie II un de nos outils principaux: la transposition de programmes
% linéaires. Précédemment, Bostan, Schost et Lecerf avaient prouvé qu'il
% est possible transposer des programmes, sans pertes en complexité
% temps ou espace, dans un modèle qui est une modeste généralisation des
% programmes sans branchements. Nous généralisons leur construction en
% concevant un langage fonctionnel standard pour lequel nous donnons un
% algorithme de transposition. Notre nouvelle transposition est aussi
% efficace que la leur sur des programmes qui font partie de leur
% modèle, mais elle permet aussi de traiter des programmes plus généraux
% avec des pertes mineures en complexité espace. Nous décrivons
% l'implantation d'un compilateur réalisant nos idées.

% Dans la Partie III, nous combinons notre transposition avec des
% techniques classiques de calcul formel et théorie de l'élimination,
% puis nous montrons des nouveaux résultats sur les tours
% d'Artin-Schreier sur des corps finis. Ceci nous permet de concevoir
% une gamme d'algorithmes qui calculent en temps quasi-optimal les
% opérations arithmetiques les plus communes sur les tours
% d'Artin-Schreier. Nous avons implanté ces algorithmes dans une
% bibliothèque logicielle que nous décrivons à la fin de cette partie.

% Enfin, la Partie IV traite le problème du calcul d'isogénies. Nous
% appliques nos techniques à une variante rapide de l'algorithme de
% Couveignes que nous avions proposée dans notre mémoire de Master, puis
% nous comparons les résultats avec d'autres algorithmes pour le calcul
% d'isogénies.



It would not be far from the truth saying that all our electronic
devices spend their time doing: 1. nothing, 2. integer arithmetics, 3.
finite field arithmetics. Your favorite CD player certainly does and
your toaster maybe will one day. This is so true, that the last
generation of Intel Core processors supports a hardware instruction
(CLMUL) for multiplication in $\F_{2^m}$~\cite{intel-carryless}.

This is because finite fields appear everywhere in telecommunications
engineering, in particular in Error Correcting Codes and
Cryptography. This thesis applies advanced algorithmic techniques to
computations in towers of extensions of finite fields, in view of
applications to elliptic curve cryptography.



\paragraph{Isogeny computation}
\label{sec:isogeny-computation}
In elliptic curve cryptography, in order to build a secure
cryptosystem, one must select a curve whose number of points contains
a large enough prime factor. The preferred method for doing this is to
randomly select a curve and then use a point-counting algorithm to
determine its cardinality. The first polynomial time point counting
algorithm for elliptic curves was due to Schoof~\cite{schoof85}, then
improved by Atkin and
Elkies~\cite{atkin88,elkies92,elkies98,schoof95}, henceforth named
SEA.

The SEA algorithm raised interest in explicit computations with
isogenies, i.e. algebraic group morphisms of elliptic curves. When
computing isogenies over finite fields one must distinguish between
the large and arbitrary characteristic. In the first case, one can use
algorithms that work for characteristic $0$, and then reduce the
result; the methods of Elkies~\cite{elkies98,morain95},
Atkin~\cite{schoof95} and Bostan, Morain, Salvy and
Schost~\cite{bostan+morain+salvy+schost08} belong to this family. When
the reduction modulo the characteristic introduces division by $0$,
these algorithms are not of help.

The first two algorithms to compute isogenies in arbitrary
characteristic are due to Couveignes~\cite{couveignes94,couveignes96}:
both have a polynomial dependency in the characteristic, which makes
them unpractical for values higher than $2$ or $3$. An algorithm
specific to characteristic $2$ was given by Lercier~\cite{lercier96};
in practice it performs faster than Couveignes' algorithms, but its
complexity is not well understood. More recently, Joux and
Lercier~\cite{joux+lercier06} and Lercier and
Sirvent~\cite{lercier+sirvent08} have shown that it is possible to
avoid division by $0$ by lifting the curves in the $p$-adics. The last
one is currently the algorithm for the arbitrary characteristic case
having the best asymptotic complexity; its complexity in the
characteristic is only logarithmic.

It is interesting to remark, however, that no algorithm to compute
isogenies has optimal or quasi-optimal complexity, with the only
exception of~\cite{bostan+morain+salvy+schost08} on a very special
case. 

The starting point of this work was Couveignes' second
algorithm~\cite{couveignes96}. It computes an isogeny by interpolating
it over the $p^k$-torsion points of the elliptic curves for a large
enough $k$; when those points are not defined on the base field, one
has to take towers of field extensions to find them. The field
extensions that naturally arise when doing this computation are
splitting fields of polynomials of the from
\[X^p - X -\alpha\text{;}\] such extension are called Artin-Schreier
extensions. 


\paragraph{Towers of finite fields}
\label{sec:towers-extensions}
Besides addition, multiplication and inversion, the arithmetic
operations of interest in a tower of finite extensions arguably are
relative traces and embeddings. For finite fields one could add
explicit Galois groups to the list as these are relatively easy to
compute with.

The arithmetic of towers of finite fields is a central question for
any computer algebra system, however it has received few attention, if
any. Magma is known for having had support for lattices of finite
fields for a long time~\cite{bosma+cannon+steel97}, but it is hard to
tell which algorithms it implements nowadays and what their
complexities are. All other results that can possibly apply to towers
of finite fields were derived in the more general context of
polynomial system solving and effective algebraic geometry, in
particular in the resolution of triangular
sets~\cite{diaz+gonzalez01,giusti+lecerf+salvy01,bostan+salvy+schost03,pascal+schost06,li+moreno+schost07,dahan+jin+moreno+schost08,boulier+lemaire+moreno01,FGLM,rouiller99,alonso+becker+roy+wormann}.

In the specific case of Artin-Schreier towers, the literature is not
extensive either.  Using ideas from~\cite{Conway:ONAG2000},
Cantor~\cite{cantor89} constructs a particular Artin-Schreier tower
suited for FFT multiplication in characteristic
$2$. In~\cite{couveignes00}, Couveignes gives an algorithm to compute
isomorphisms between Artin-Schreier towers; however, his algorithm
needs as a prerequisite a fast multiplication algorithm in some towers
of a special kind, called ``Cantor towers''
in~\cite{couveignes00}. Such an algorithm is unfortunately not in the
literature, making the results of~\cite{couveignes00} non practical.


\paragraph{Transposition principle}
\label{sec:transp-princ}
One algorithmic tool that we shall study in depth and apply throughout
the whole document is the \emph{transposition principle}, which is the
language-theoretic counterpart to algebraic duality.

The transposition principle was discovered in electrical network
theory by Bordewijk\cite{bordewijk57}, then proved in its general form
by Fiduccia~\cite{fiduccia:phd}; but it only became popular in
computer algebra much later through the works of Kaltofen, Yagati,
Shoup, von zur Gathen and
others~\cite{kaltofen+lakshman89,vzgathen+shoup92,shoup94,shoup95,shoup99,hanrot+quercia+zimmermann}. It
states that
\begin{quote}
  To any \emph{$R$-algebraic} algorithm computing a linear function
  $f:M\ra N$, where $M,N$ are $R$-modules, corresponds an algebraic
  algorithm that computes $\dual{f}$ using the same number of
  algebraic operations.
\end{quote}

The transposition principle is important in computer algebra because
it permits to derive asymptotically good algorithms that were not
otherwise evident. One big step forward in the understanding of it was
done by Bostan, Lecerf and Schost~\cite{bostan+lecerf+schost:tellegen}
who, extending work of Shoup~\cite{shoup95}, remarked that
transposition can be systematically applied to a restricted
programming language. It is also remarkable that the transposition
principle has a strong connection with automatic
differentiation~\cite{baur+strassen83,kaltofen+lakshman89,Ka2K,gashkov+gashkov05,sergeev08}.

In this document we investigate more in depth the relationships
between the transposition principle and programming languages. We use
the theory of typed purely functional languages~\cite{pierce} as
framework, because its elegant mathematical structure permits to
reason at an algebraic level on programs.


\paragraph{Outline, contributions and software packages}
\label{sec:outl-contr}
This document is divided in four parts. Part~\ref{cha:algebra} recalls
the basic notions from algebra and computer algebra that we will use
later.

Part~\ref{part:transp-princ} studies the transposition principle. In
Chapter~\ref{cha:algebr-compl-dual} we present the arithmetic circuit
model and the straight line program model, and prove the principle in
them. Then we discuss the relationships with automatic
differentiation. Chapter~\ref{cha:autom-transp-code} is a
collaboration with Schost. We study the relationships between the
arithmetic circuit model and functional programming languages, then we
show that transposition can be applied algorithmically to a generic
functional language. Some complementary observations on the
categorical semantics of arithmetic circuits and their application to
automatic transposition are given in
Appendix~\ref{cha:basic-categ-theory}, which is joint work with
Boespflug.

Part~\ref{part:fast-arithm-using} is devoted to arithmetics in towers
of extensions. We start by reviewing the general theory of
zero-dimensional ideals and rational univariate representations in
Chapter~\ref{cha:trace-computations}. Here, the results of
Part~\ref{part:transp-princ} are the key to obtain asymptotically fast
algorithms. The algorithms of this chapter are then applied in
Chapter~\ref{cha:artin-schr-towers}, where we provide asymptotically
good algorithms for Artin-Schreier towers (fruit of another
collaboration with Schost).

Finally Part~\ref{part:appl-isog-comp} applies the results of the
previous chapters to isogeny computation. After some general
references on elliptic curves in Chapter~\ref{cha:ellipt-curv-isog},
we review in Chapter~\ref{cha:algor-small-char} the most efficient
algorithms to compute isogenies over finite fields, and present new
asymptotically fast variants of Couveignes' algorithm, along with a
promising generalization in
Section~\ref{sec:bounded}. Chapter~\ref{cha:experimental-results} then
discusses implementation and experimental results for this part of the
document.

Theory would be meaningless without practice. Similarly, this
manuscript would make no sense if it was not accompanied by our
software packages. The great majority of the algorithms we present
here have been implemented, packaged and distributed under open source
licences. So, all the algorithms of
Chapter~\ref{cha:artin-schr-towers} can be found in the \texttt{C++}
library \texttt{FAAST}, available from
\url{http://www.lix.polytechnique.fr/Labo/Luca.De-Feo/FAAST/}. At the
moment we write, the compiler for the language \texttt{transalpyne} of
Chapter~\ref{cha:autom-transp-code} is not distributed yet; we are
currently working on the first stable release and hope to start
distributing it by the beginning of 2011. It will be available from
\url{ http://transalpyne.gforge.inria.fr/}.




%%% Local Variables: 
%%% mode:flyspell
%%% ispell-local-dictionary:"american"
%%% mode: TeX-PDF
%%% mode: reftex
%%% TeX-master: "../these"
%%% End: 
