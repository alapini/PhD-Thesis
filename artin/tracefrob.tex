\section{Pseudotrace and frobenius}
\label{sec:pseudotrace-frobenius}
We recall the definitions from Section \ref{sec:arithmetics}:
\begin{align*}
  \frob^n &: x \mapsto x^{p^n} \text{,}\\
  \PTr_{(n,m)} &: x \mapsto \sum_{l=0}^{n-1} x^{p^{ml}} \text{.}
\end{align*}
Recall the notation $\PTr_n = \PTr_{(n,1)}$, we look for efficient
algorithms to compute $\frob^n$ and $\PTr_n$ for a $v\wrt\U_i$.

Naive implementations would require $O(n\Mult(p^id)\log p)$
$\F_p$-operations for both. In this section we are going to show how
to make the factor $n$ drop down to essentially $\log_pn$ at the cost
of some extra storage. We will first deal with the case $n=p^jd$ when
$j<i$, then with the generic $n$ case.

Some easy equations are important to our algorithms. For the frobenius
\begin{gather}
  \label{eq:frobeniussum}
  \frob^{m+n} = \frob^m\circ\frob^n \text{,}\qquad
  \frob^{mn} = \left(\frob^m\right)^n\text{,}\\
  \label{eq:frobenius-pseudo}
  \frob^n(x_i) = x_i + \PTr_n(\gamma_{i-1}) \text{.}
\end{gather}
The last one is specific to the Artin-Schreier context and is easily
verified by induction.

As for the pseudotrace,
\begin{gather}
  \label{eq:pseudotracecomp}
  \PTr_{mn}(v) = \left(\PTr_{(m,n)}\circ\PTr_{n}\right)(v) =
  \sum_{l=0}^{m-1} \left(\PTr_{n}(v)\right)^{p^{ln}} =
  \sum_{l=0}^{m-1}\frob^{ln}\left(\PTr_{n}(v)\right)
  \text{,}\\
  \label{eq:pseudotracesum}
  \PTr_{m+n}(v) = \PTr_{m}(v) + \PTr_{n}(v^{p^m}) =
  \PTr_{m}(v) + \frob^m\left(\PTr_{n}(v)\right)\text{.}
\end{gather}

Observe that, if $v\in\U_i$, then $\frob^{p^id}(v) = v$ and
$\PTr_{p^id}(v) = \Tr_{\U_i/\U_0}(v)$. Then, by using equations
\eqref{eq:frobeniussum} and \eqref{eq:pseudotracecomp} and the
algorithm for the trace given in Section \ref{sec:arithmetics}, one
sees that the only relevant case is when $n<p^id$.


\subsection{Iterated Frobenius}

We will begin with the frobenius: we want to compute $\frob^n(v)$. If
$v\wrt\U_i$, then it can be written as $v=v_0+\cdots+v_{p-1}x_i^{p-1}$
with $v_h\wrt\U_{i-1}$ as in Section \ref{sec:level-embedding}. Then,
by \eqref{eq:frobenius-pseudo} and the linearity of the frobenius, we
deduce
\begin{multline}
  \label{eq:frobeniuscomp}
  \frob^n(v) = \frob^n\left(\sum_{h=0}^{p-1} v_{h}x_i^{h}\right) =
  \sum_{h=0}^{p-1} \frob^n(v_h)\left(x_i + \PTr_n(\gamma_{i-1})\right)^{h} =\\
  \sum_{h=0}^{p-1} x_i^h \sum_{k=h}^{p-1}
  \binom{k}{h}\frob^n(v_k)\PTr_n(\gamma_{i-1})^{k-h}
  \text{.}
\end{multline}

In the case $n=p^jd$, our algorithm derives from the recursive
application of equation \eqref{eq:frobeniuscomp}. This requires
computing all the values $\PTr_{p^jd}(\gamma_{i'})^h$ for $i'<i$ and
$1\le h<p$. On the other hand, the algorithm for the pseudotrace uses
the iterated frobenius as a subroutine, thus giving a \emph{dangerous}
double recurrence between them. To avoid this, we are going to suppose
that all the $\PTr_{p^jd}(\gamma_{i})^h$ for any $i$, $0\le j\le i$
and $1\le h < p$ are precomputed. The discussion on of how we actually
precompute such values is delayed to Section
\ref{sec:pseudotrace-frobenius:precomputation}.

\begin{figure}[!htb]
  \begin{algorithm}
    {Iterated Big Frobenius}
    {$v\wrt\U_i$, $j\le i$.}
    {$\frob^{p^jd}(v)$.}
  \item \label{alg:frob:base} If $j = i$, then return $v$.
  \item Else
    \begin{enumerate}
    \item \label{alg:frob:push} $v_0, \ldots, v_{p-1} = $
      Push-down($v$);
    \item \label{alg:frob:for} for $h = p-1$ to $0$
      \begin{enumerate}
      \item \label{alg:frob:rec} compute $\tilde{v}_h = $ Iterated
	Big Frobenius($v_h, j$);
      \item \label{alg:frob:comp} compute $t_h = \sum_{k=h}^{p-1}
	\binom{k}{h}\tilde{v}_k\PTr_{p^jd}(\gamma_{i-1})^{k-h}$;
      \end{enumerate}
    \item \label{alg:frob:lift} compute and return Lift-up($t_0$,
    $\ldots$, $t_{p-1}$).
    \end{enumerate}
  \end{algorithm}
\end{figure}

\sloppy
\begin{theorem}
  \label{th:frob}
  The algorithm \alg{Iterated Big Frobenius} is correct and computes
  its result in
  $O\left((i-j)\Mult(p^{i+1}d)\log(p^{\frac{i+j}{2}}d)\right)$
  $\F_p$-operations.
\end{theorem}
\fussy
\begin{proof}
  Correctness follows immediately from equation
  \eqref{eq:frobeniuscomp} and the fact that if $v\in\U_i$ then
  $\frob^{p^id}(v)=v$.

  We note $\Frob(i,p^jd)$ for the complexity of the algorithm on input
  $v\wrt\U_i$ and $j$, then by observing the step \ref{alg:frob:base}
  we conclude $\Frob(i,p^id) = O(1)$.
  
  Step \ref{alg:frob:rec} does $p$ recursive calls each of which costs
  $F(i-1, p^jd)$ operations. Step \ref{alg:frob:comp} does $p(p+1)/2$
  times a multiplication in $\U_{i-1}$, a computation of a binomial
  coefficient modulo $p$ and a multiplication by a scalar in
  $\U_{i-1}$, that cost respectively $O\left(\Mult(p^{i-1}d)\right)$,
  $O(p)$ and $O\left(p^{i-1}d\right)$; plus $p(p-1)/2$ additions in
  $\U_{i-1}$ that cost each $O\left(p^{i-1}d\right)$. The overall cost
  for step \ref{alg:frob:comp} is then $O\left(p^2\Mult(p^{i-1}d)\right)$.

  Finally \ref{alg:frob:push} and \ref{alg:frob:lift} take $\Push(i)$
  and $\Lift(i)$, that is $O\left(\Mult(p^{i+1}d)\log(p^id)\right)$,
  which is seen to dominate over step \ref{alg:frob:comp}. Putting
  things together, we have the formula
  \begin{equation*}
    \Frob(i,p^jd) =
    p\Frob(i-1,p^jd) + O\left(\Mult(p^{i+1}d)\log(p^id)\right)
  \end{equation*}
  from which we deduce
  \begin{multline}
    \label{eq:F(i,j)}
    \Frob(i,p^jd) = O\left(p^{i-j} + \sum_{l=j+1}^i
    p^{i-l}\Mult(p^{l+1}d)\log(p^ld)\right) \le\\
    O\left(\Mult(p^{i+1}d)\sum_{l=j+1}^i\log(p^ld)\right) =
    O\left((i-j)\Mult(p^{i+1}d)\log(p^{\frac{i+j}{2}}d)\right)
    \text{.}
  \end{multline}
\end{proof}

We now investigate the case of the generic $n<p^id$. Using equation
\eqref{eq:frobeniussum}, one sees that
\begin{equation*}
  \frob^{cp^jd + r}(v) = \frob^r\left(\left(\frob^{p^jd}\right)^c(v)\right)
  \text{,}
\end{equation*}
Now, write $n = r+\sum_jc_jp^jd$ with $c_j<p$ for every $j$ and
$r=n\bmod d$, so that the sum has less than $\log_pn$ terms. We deduce
\begin{multline*}
  \Frob(i,n) = \Frob(i,r) + \sum_jc_j\Frob(i,p^jd) \le
  \Frob(i,r) +
  p\sum_{j=0}^{\lfloor\log_pn\rfloor} 
  O\left(\Mult(p^{i+1}d)\sum_{l=j+1}^i\log(p^ld)\right)=\\
  \Frob(i,r) + O\left(pi\Mult(p^{i+1}d)\log(p^id)\log_pn\right) =
  \Frob(i,r) + O\left(\Frob(i,d)p\log_pn\right)
  \text{,}
\end{multline*}
so that the only problem left to solve is to compute $\frob^{n\bmod
  d}(v)$. This can be done in $O(d\Mult(p^id)\log p)$ by a naive
approach, but this is not satisfactory when $d$ is too large. A
classical solution is to use a modular composition approach
\cite{}. Recall from Section \ref{sec:introduction} that the result of
\alg{ModComp($f,g,h$)}, where $f$, $g$ and $h$ are polynomials of
degree at most $m$ in $\F_p[X]$, is the polynomial $f(g)\bmod h$. We
note $\ModComp(m)$ for its complexity in $\F_p$ operations.

The algorithm we give derives from equation \eqref{eq:frobeniuscomp}
and is essentially the same as \alg{Iterated Big Frobenius}, but we
cannot rely anymore on the structure of the tower at the bottom of the
recurrence. Again, we are going to suppose that
$\PTr_{2^e}(\gamma_i)^h$ is precomputed for any $i$, $1\le e<\log_2d$
and $1\le h<p$.

\begin{figure}[!htb]
  \begin{algorithm}
    {Iterated Little Frobenius}
    {$v\wrt\U_i$, $e$ such that $2^e<d$.}
    {$\frob^{2^e}(v)$.}
  \item \label{alg:l-frob:base-n} If $e = 0$, then return $v^p$.
  \item \label{alg:l-frob:modcomp} Else, if $i=0$,
    \begin{enumerate}
    \item \label{alg:l-frob:rec1}compute $X^{(e-1)}=$ Iterated Little
      Frobenius($x_0, e-1$);
    \item let $Q_0$ be the minimal polynomial of $x_0$;
    \item \label{alg:l-frob:e}compute $X^{(e)}=$
      ModComp($X^{(e-1)},X^{(e-1)},Q_0$);
    \item \label{alg:l-frob:v-e} compute and return
      ModComp($v,X^{(e)},Q_0$).
    \end{enumerate}
  \item \label{alg:l-frob:i}Else,
    \begin{enumerate}
    \item \label{alg:l-frob:push} $v_0, \ldots, v_{p-1} = $
      Push-down($v$);
    \item \label{alg:l-frob:for} for $h = p-1$ to $0$
      \begin{enumerate}
      \item \label{alg:l-frob:rec} compute $\tilde{v}_h = $ Iterated
	Little Frobenius($v_h, e$);
      \item \label{alg:l-frob:comp} compute $t_h = \sum_{k=h}^{p-1}
	\binom{k}{h}\tilde{v}_k\PTr_{2^e}(\gamma_{i-1})^{k-h}$;
      \end{enumerate}
    \item \label{alg:l-frob:lift} compute and return Lift-up($t_0$,
    $\ldots$, $t_{p-1}$).
    \end{enumerate}
  \end{algorithm}
\end{figure}

\sloppy
\begin{theorem}
  \label{th:l-frob}
  The algorithm \alg{Iterated Little Frobenius} is correct and computes
  its result in
  $O\left(ep^i\ModComp(d) + i\Mult(p^{i+1}d)\log(p^id)\right)$
  $\F_p$-operations.
\end{theorem}
\fussy
\begin{proof}
  Correctness of step \ref{alg:l-frob:base-n} is evident and the one
  of step \ref{alg:l-frob:i} is a direct consequence of equation
  \eqref{eq:frobeniuscomp}.

  For the correctness of step \ref{alg:l-frob:modcomp}, $X^{(e-1)}$ is
  seen as a polynomial in $\F_p[X]$, then by induction hypothesis
  $X^{(e-1)}\equiv X^{p^{2^{e-1}}}\bmod Q_0$. Observe that we may as
  well see $X^{(e-1)}$ as an element in $\U_0$ --we will note
  $x^{(e-1)}$ in this case--, then $x^{(e-1)}=\frob^{2^{e-1}}(x_0)$ by
  induction hypothesis. We deduce
  \begin{equation*}
    X^{(e-1)}(x^{(e-1)}) =
    (x^{(e-1)})^{p^{2^{e-1}}} + P(x^{(e-1)})Q_0(x^{(e-1)})
    \text{,}
  \end{equation*}
  but $x^{(e-1)}$ is a conjugate of $x_0$, thus its minimal polynomial
  is again $Q_0$ and we conclude
  \begin{equation*}
    X^{(e-1)}(x^{(e-1)}) = \frob^{2^{e-1}}(x^{(e-1)}) =
    \frob^{2^{e-1}}(\frob^{2^{e-1}}(x_0)) =
    \frob^{2^e}(x_0) \text{,}
  \end{equation*}
  and this justifies step \ref{alg:l-frob:e}.

  To justify step \ref{alg:l-frob:v-e}, just look at $v$ as a
  polynomial in $\F_p[X]$, then 
  \begin{equation*}
    \frob^{2^e}(v) =
    \frob^{2^e}(v(x_0)) = v\left(\frob^{2^e}(x_0)\right) =
    v\left(x^{(e)}\right) = v\left(X^{(e)}\right) \bmod Q_0
  \end{equation*}
  and this ends the correctness proof.

  Now note $\Frob(i,2^e)$ the complexity of the algorithm on input
  $v\wrt\U_i$ and $e$, then $\Frob(i,2^0) = \Mult(p^id)\log p$.

  When $i=0$, step \ref{alg:l-frob:rec1} contributes
  $\Frob(0,2^{e-1})$ operations and steps \ref{alg:l-frob:e} and
  \ref{alg:l-frob:v-e} contribute $\ModComp(d)$ each, thus giving
  \begin{equation*}
    \Frob(0,2^e) = \Frob(0,2^{e-1}) + 2C(d) = 
    \Mult(d)\log p+2eC(d)\text{.}
  \end{equation*}

  When $i\ge1$ the complexity analysis proceeds exactly like in the
  proof of theorem \ref{th:frob} and tells us
  \begin{multline*}
    \Frob(i,2^e) =
    p\Frob(i-1,2^e) + O\left(\Mult(p^{i+1}d)\log(p^id)\right)\le\\
    p^i\Frob(0,2^e) + O\left(i\Mult(p^{i+1}d)\log(p^id)\right) =
    O\left(ep^i\ModComp(d) + i\Mult(p^{i+1}d)\log(p^id)\right)
    \text{.}
  \end{multline*}
\end{proof}

\begin{remark}
  \label{rk:memo}
  Observe that we could have avoided steps \ref{alg:l-frob:rec1} and
  \ref{alg:l-frob:e} by storing all the values of $\frob^{2^e}(x_0)$
  for $0\le e<\log_2d$. This makes $\Frob(0,2^e)$ drop down to
  $\ModComp(d)$, but demands to store $\lceil\log_2d\rceil$ elements
  of $\U_0$, that is $d\lceil\log_2d\rceil$ elements of $\F_p$.
\end{remark}

Now, if we want to compute $\frob^n(v)$ for any $r<d$, we can write it
in base $2$ as $\sum_{e=0}^cr_e2^e$ and use equation
\eqref{eq:frobeniussum} to compute
\begin{equation*}
  \frob^{n}(v) =
  \frob^{r_c2^c}\left(\cdots\left(\frob^{r_12^1}\left(\frob^{r_02^0}(v)\right)\right)\right)
  \text{.}
\end{equation*}
Observe that when $r_e=1$, $\frob^{r_e2^e}$ can be computed by
\alg{Iterated Little Frobenius}, while when $r_e=0$, $\frob^{r_e2^e}$
is simply the identity. We deduce
\begin{equation*}
  \Frob(i,r) = \sum_{e=0}^cr_e\Frob(i,2^e)\le
  \sum_{e=0}^{c}\Frob(i,2^e)
  \text{.}
\end{equation*}

We can now use remark \ref{rk:memo} and store (at least temporarily)
the values of $\frob^{2^e}(x_0)$ for $0\le e<c$. This makes
$\Frob(i,2^e)$ drop down to $O\left(p^i\ModComp(d) +
i\Mult(p^{i+1}d)\log(p^id)\right)$ when $e<c$, while letting unchanged
$\Frob(i,2^c)$.  Since $c\le\log_2r$, we deduce that
\begin{equation*}
  \Frob(i,r) \le \Frob(i,2^c) + \sum_{e=0}^{c-1}\Frob(i,2^e)\le
  O\left(p^i\ModComp(d)\log r + i\Mult(p^{i+1}d)\log(p^id)\log r\right)
  \text{.}
\end{equation*}

Putting things together, we deduce the following
\sloppy
\begin{corollary}
  The number of $\F_p$ operations needed to compute
  $\frob^n(v)\wrt\U_i$ is $O\left(p^i\ModComp(d)\log(n\bmod d) +
  pi\Mult(p^{i+1}d)\log(p^id)\log_pn\right)$.
\end{corollary}
\fussy

Notice that we could have used the modular composition approach all
the way up to $n$, instead of using two different algorithms for the
quotient and the reminder of $n$ divided by $d$. At the expense of
some more precomputed elements, the asymptotic complexity of such an
approach is
\begin{equation*}
  O\left(p^i\ModComp(d)\log n + i\Mult(p^{i+1}d)\log(p^id)\log n\right)
  \text{,}
\end{equation*}
which has a slightly better second member (by a factor of $p/\log p$)
and a slightly worse first member (by a factor of
$\log\frac{n}{d}$). From a practical point of view, though, this
trade-off would be sensibly slower for all reasonable
$p$'s. Furthermore, the interest of having a more efficient algorithm
for the case $n=p^jd$ will be clear in Section
\ref{sec:couveignes-algorithm}.


\subsection{Pseudotrace}

The algorithms for the pseudotrace are direct consequences of
equations \eqref{eq:pseudotracecomp} and
\eqref{eq:pseudotracesum}. This time we will treat the case $n\le d$
first.

\begin{figure}[h]
  \begin{algorithm}
    {Little Pseudotrace}
    {$v\wrt\U_i$, $1\le n\le d$.}
    {$T_{n}(v)$.}
  \item \label{alg:l-pseudo:base}If $n = 1$, then return $v$.
  \item \label{alg:l-pseudo:even}Else, if $n=2^e$, 
    \begin{enumerate}
    \item \label{alg:l-pseudo:rec}compute $t = $ Little Pseudotrace($v$,
      $2^{e-1}$);
    \item \label{alg:l-pseudo:frob} compute $T = $ Iterated Little
      Frobenius($t$, $e-1$);
    \item \label{alg:l-pseudo:sum}return $t + T$.
    \end{enumerate}
  \item \label{alg:l-pseudo:odd}Else, let $2^e<n< 2^{e+1}$,
    \begin{enumerate}
    \item compute $t_0 = $ Little Pseudotrace($v$, $2^e$);
    \item compute $t_1 = $ Little Pseudotrace($v$, $n \bmod 2^e$);
    \item \label{alg:l-pseudo:frob2}compute $T_1 = $ Iterated Little
      Frobenius($t_1$, $e$);
    \item compute and return $t_0 + T_1$.
    \end{enumerate}
  \end{algorithm}
\end{figure}

\sloppy
\begin{theorem}
  \label{th:l-pseudo}
  The algorithm \alg{Little Pseudotrace} is correct and computes its
  output in $O\left(p^i\ModComp(d)\log n +
  i\Mult(p^{i+1}d)\log(p^id)\log n\right)$ $\F_p$-operations.
\end{theorem}
\fussy
\begin{proof}
  Correctness of step \ref{alg:l-pseudo:base} is evident. Step
  \ref{alg:l-pseudo:even} follows from equation
  \eqref{eq:pseudotracecomp} and $2^{e-1}<d$, thus step
  \ref{alg:l-pseudo:frob} is correct. Step \ref{alg:l-pseudo:odd}
  follows from equation \eqref{eq:pseudotracesum} and $2^e<n\le d$,
  thus step \ref{alg:l-pseudo:frob2} is correct.

  Note $\Ptr(i,n)$ the complexity of the algorithm on input
  $v\wrt\U_i$ and $n$. Clearly, $\Ptr(i,1)=O(1)$. From step
  \ref{alg:l-pseudo:even} we deduce
  \[\Ptr(i,2^c) = \Ptr(i,2^{c-1}) + \Frob(i,c-1) + O(p^id)\]
  and we can ignore the term $O(p^id)$. As a consequence
  \begin{equation*}
    \Ptr(i,2^c) = \sum_{e=0}^{c-1} \Frob(i,2^e)\text{.}
  \end{equation*}
  We now use again remark \ref{rk:memo} and store $\frob^{2^e}(x_0)$
  for $0\le e\le\log_2n$. This makes $\Frob(i,2^e)$ drop to
  $O\left(p^i\ModComp(d) + i\Mult(p^{i+1}d)\log(p^id)\right)$ and
  \begin{equation*}
    \Ptr(i,2^c) = O\left(cp^i\ModComp(d) +
    ci\Mult(p^{i+1}d)\log(p^id)\right) \text{.}
  \end{equation*}

  From step \ref{alg:l-pseudo:odd} we deduce that if $2^c<n<2^{c+1}$
  \begin{equation*}
    \Ptr(i,n) =
    \Ptr(i, 2^c) + \Ptr(i, n\bmod 2^c) + \Frob(i, 2^c) + O(p^id)
  \end{equation*}
  and we can ignore the term $O(p^id)$. Let $\sum_{e=0}^cn_e2^e$ be
  the binary expansion of $n$, then
  \begin{equation}
    \label{eq:ptr-rec}
    \Ptr(i,n) = \sum_{e=1}^c n_e\left(\Ptr(i, 2^e) + \Frob(i,2^e)\right)
    \text{.}
  \end{equation}
  Observe that all the recursive calls in the algorithm have $v$ as
  their first argument. Thus we can again use a dynamic programming
  technique to compute just once the $\PTr_{2^e}(v)$'s, in fact they
  are all computed for $1\le e \le c$ by step \ref{alg:l-pseudo:rec}
  during the call to \alg{Little Pseudotrace($v,2^c$)}. As a
  consequence, equation \eqref{eq:ptr-rec} becomes
  \begin{equation*}
    \Ptr(i,n) = \Ptr(i, 2^c) + \sum_{e=1}^c n_e\Frob(i,2^e) =
    O\left(cp^i\ModComp(d) + ci\Mult(p^{i+1}d)\log(p^id)\right)
    \text{.}
  \end{equation*}
  Observing that $c\le\log_2n$ concludes the proof.
\end{proof}

Computing now $\PTr_{p^jd}(v)$ is a simple task.

\begin{figure}[h]
  \begin{algorithm}
    {Big Pseudotrace}
    {$v\wrt\U_i$, $j<i$.}
    {$T_{p^jd}(v)$.}
  \item \label{alg:pseudo:base}If $j = 0$, then compute and return
    Little Pseudotrace($v$, $d$).
  \item Else
    \begin{enumerate}
    \item \label{alg:pseudo:rec}compute $t_0 = $ Big Pseudotrace($v$,
      $j-1$);
    \item \label{alg:pseudo:frob}for $h = 1$ to $p-1$
      \begin{enumerate}
      \item compute $t_h = $ Iterated Frobenius($t_{h-1}, j-1$);
      \end{enumerate}
    \item \label{alg:pseudo:sum}return $t_0 + t_1 + \cdots + t_{p-1}$.
    \end{enumerate}
  \end{algorithm}
\end{figure}

\sloppy
\begin{theorem}
  \label{th:b-pseudo}
  The algorithm \alg{Big Pseudotrace} is correct and computes its
  result in $O\left(p^i\ModComp(d)\log d + (jp+\log
  d)i\Mult(p^{i+1}d)\log(p^id)\right)$ $\F_p$-operations.
\end{theorem}
\fussy
\begin{proof}
  The correctness is a direct consequence of equation
  \eqref{eq:pseudotracecomp}, in fact
  \begin{equation*}
    \PTr_{p^jd}(v) =
    \sum_{l=0}^{p-1}\left(\frob^{p^jd}\right)^l\left(\PTr_{p^{j-1}d}(v)\right)
    \text{.}
  \end{equation*}
  
  We note $\Ptr(i,p^jd)$ for the complexity of the algorithm on input
  $v\wrt\U_i$ and $j$. We already know from theorem \ref{th:l-pseudo}
  that $\Ptr(i,d)=O\left(p^i\ModComp(d)\log d +
  i\Mult(p^{i+1}d)\log(p^id)\log d\right)$
  
  When $j>0$, step \ref{alg:pseudo:rec} costs $\Ptr(i,p^{j-1}d)$, step
  \ref{alg:pseudo:frob} costs $(p-1)\Frob(i,p^{j-1}d)$ and step
  \ref{alg:pseudo:sum} costs $(p-1)O(p^id)$ operations. Putting things
  together and using theorem \ref{th:frob}, we have
  \begin{equation*}
    \Ptr(i,p^jd) =
    \Ptr(i,p^{j-1}d) + p\Frob(i,p^{j-1}d) + O\left(p^{i+1}d)\right)
  \end{equation*}
  and we can ignore the term $O(p^{i+1}d)$ since its clearly dominated
  by ${p\Frob(i,p^{j-1}d)}$.
  
  Using our knowledge of $\Ptr(i,d)$ and the first inequality in
  \eqref{eq:F(i,j)}, we have
  \begin{equation*}
    \Ptr(i,p^jd) \le O\left(p^i\ModComp(d)\log d +
    i\Mult(p^{i+1}d)\log(p^id)\log d+
    \sum_{l=1}^jp\Mult(p^{i+1}d)\sum_{m=l}^i\log(p^md)\right)
  \end{equation*}
  and, by bounding $\sum_{l=1}^j \sum_{m=l}^i\log(p^md)$ with
  $\sum_{l=1}^j\sum_{m=1}^i\log(p^md)$, we conclude
  \begin{equation*}
    \Ptr(i,j) \le
    O\left(p^i\ModComp(d)\log d + i\Mult(p^{i+1}d)\log(p^id)\log d +
    ijp\Mult(p^{i+1}d)\log(p^id)\right) \text{.}
  \end{equation*}
\end{proof}

Now, to compute $\PTr_n(v)$ for a generic $n$, let $n = r +
\sum_{j=0}^{c}c_jp^jd$ with $c_j<p$ and $r<d$, then by equations
\eqref{eq:pseudotracecomp} and \eqref{eq:pseudotracesum}
\begin{equation*}
  \PTr_n(v) =
  \PTr_r(v) + \frob^r\left(
  \sum_{h=0}^{c_0-1}\left(\frob^{d}\right)^h(\PTr_d(v)) + \left(\frob^d\right)^{c_0}\left(
  \sum_{h=0}^{c_1-1}\left(\frob^{pd}\right)^h(\PTr_{pd}(v)) + \cdots
  \right)
  \right)
  \text{,}
\end{equation*}
so that in the worse case
\begin{equation*}
  \Ptr(i,n) = \Ptr(i,r) + \sum_{j=0}^c \Ptr(i,p^jd) + O(p)\Frob(i,p^jd)
  \text{.}
\end{equation*}
Observing that the $\PTr_{p^jd}(v)$ can be computed just once while
computing \alg{Big Pseudotrace(v,c)}, we have
\begin{multline*}
  \Ptr(i,n) = \Ptr(i,r) + \Ptr(i,p^cd) + O(p)\sum_{j=0}^c \Frob(i,p^jd) =
  \Ptr(i,r) + \Ptr(i,p^cd) + O\left(pic\Mult(p^{i+1}\log(p^id)\right)
  \text{.}
\end{multline*}
Using the results of theorems \ref{th:l-pseudo} and \ref{th:b-pseudo},
we conclude
\begin{equation*}
  \Ptr(i,n) = O\left(p^i\ModComp(d)\log d +
  (pc +\log d)i\Mult(p^{i+1}d)\log(p^id)\right) =
  O\left( \Ptr(i, p^cd) \right) \text{.}
\end{equation*}



\subsection{The precomputation}
\label{sec:pseudotrace-frobenius:precomputation}
In the previous Sections we eventually made the assumption that some
values had been precomputed. Often, like in remark \ref{rk:memo}, such
precomputations just account to use a dynamic programming technique
and can thus be implemented by a memoization technique and need no
further justification.

Nevertheless, two sets of values need to be proven actually possible
to compute and the complexity of such precomputation needs to be
evaluated. These are the set of ${\PTr_{p^jd}(\gamma_i)^h\wrt\U_i}$
for any $i$, $0\le j\le i$ and $1\le h < p$ and the set of
$\PTr_{2^e}(\gamma_i)^h\wrt\U_i$ for any $i$, $1\le e < \log_2d$ and
$1\le h <p$.

We will start from the second set. One call to \alg{Little
  Pre-pseudotrace($i$, $\lfloor\log_2d\rfloor$)} suffices to perform
such precomputation. Observe that it takes a constant time to compute
$\gamma_i\wrt\U_i$ since it is just the polynomial $x_i^{2p-1}$.

\begin{figure}[h]
  \begin{algorithm}
    {Little Pre-pseudotrace}
    {$i$, $e\ge1$.}
    {Stores $\PTr_{2^{e'}}(\gamma_i)^h$ for $1\le h < p$ and $1\le e'\le e$.}
  \item \label{alg:l-prepseudo:base}If $e = 1$, then $t = \gamma_i$;
  \item \label{alg:l-prepseudo:even}else, 
    \begin{enumerate}
    \item \label{alg:l-prepseudo:rec}compute Little
      Pre-pseudotrace($i$, $e-1$);
    \item \label{alg:l-prepseudo:retrieve}let $t =
      \PTr_{2^{e-1}}(\gamma_i)$;
    \end{enumerate}
  \item \label{alg:l-prepseudo:frob} compute $T = $ Iterated Little
    Frobenius($t$, $e-1$);
  \item \label{alg:l-prepseudo:sum} compute $T_1 = t + T$;
  \item \label{alg:l-prepseudo:for}for $h = 2$ to $p-1$, compute $T_h =
    T_{h-1}T_h$;
  \item store $T_1,\ldots,T_{p-1}$.
  \end{algorithm}
\end{figure}

\sloppy
\begin{theorem}
  The algorithm \alg{Little Pre-pseudotrace} is correct and performs
  its computation in $O\left(ep^i\ModComp(d) +
  ei\Mult(p^{i+1}d)\log(p^id)\right)$ $\F_p$-operations.
\end{theorem}
\fussy
\begin{proof}
  Observe that, when $e>1$, steps \ref{alg:l-prepseudo:retrieve} and
  \ref{alg:l-prepseudo:frob} need all the $\PTr_{2^{e-1}}(\gamma_i)^h$
  for $1\le h<p$ to be already stored. To ensure this, we use
  induction over $e$. For $e=1$ those values are not needed and the
  algorithm stores $\PTr_{2}(\gamma_i)^h$ for $1\le h<p$. For $e>1$,
  observe that step \ref{alg:prepseudo:rec} stores exactly those
  values by induction hypothesis and it is called before
  \ref{alg:l-prepseudo:retrieve} and \ref{alg:l-prepseudo:frob}.
  
  Then, correctness follows from equation \eqref{eq:pseudotracecomp},
  in the same way as for the algorithm \alg{Little Pseudotrace}.

  As for the complexity, observe that the algorithm is essentially
  identical to \alg{Little Pseudotrace} when asked to compute a
  pseudotrace that is a power of two. The only supplementary step is
  \ref{alg:l-prepseudo:for} that takes $p\Mult(p^id)$ operations and
  is thus dominated by step \ref{alg:l-prepseudo:frob}. The complexity
  is then $O(\Ptr(i,2^e))$.
\end{proof}

We use the same approach to compute $\PTr_{p^jd}(\gamma_i)^h$: one
call to \alg{Big Pre-pseudotrace($i$, $i$)} will suffice.

\begin{figure}[h]
  \begin{algorithm}
    {Big Pre-pseudotrace}
    {$i$, $j\le i$.}
    {Stores $\PTr_{p^{j'}d}(\gamma_i)^h$ for $1\le h < p$ and $j'\le j$.}
  \item \label{alg:prepseudo:base}If $j = 0$, compute $T_1 = $ Little
    Pseudotrace($\gamma_i$, $d$);
  \item else
    \begin{enumerate}
    \item \label{alg:prepseudo:rec}compute Big Pre-pseudotrace($i$, $j-1$);
    \item \label{alg:prepseudo:retrieve}let $t_0 =
      \PTr_{p^{j-1}d}(\gamma_i)$;
    \item for $h = 1$ to $p-1$,
      \begin{enumerate}
      \item \label{alg:prepseudo:frob}compute $t_h = $ Iterated
        Frobenius($t_{h-1}, j-1$);
      \end{enumerate}
    \item compute $T_1 = t_0 + t_1 + \cdots + t_{p-1}$;
    \end{enumerate}
  \item \label{alg:prepseudo:for}for $h = 2$ to $p-1$, compute $T_h =
    T_{h-1}T_h$;
  \item store $T_1,\ldots,T_{p-1}$.
  \end{algorithm}
\end{figure}

\sloppy
\begin{theorem}
  The algorithm \alg{Big Pre-pseudotrace} is correct and performs its
  computation in $O\left(p^i\ModComp(d)\log d + (jp+\log
  d)i\Mult(p^{i+1}d)\log(p^id)\right)$ $\F_p$-operations.
\end{theorem}
\fussy
\begin{proof}
  Step \ref{alg:prepseudo:base} can be executed if we assume that
  \alg{Little Pre-pseudotrace} has already been executed.
  
  Observe that steps \ref{alg:prepseudo:retrieve} and
  \ref{alg:prepseudo:frob} need all the $\PTr_{p^{j-1}d}(\gamma_i)^h$
  for $1\le h<p$ to be already stored. To ensure this, we use
  induction over $j$. For $j=0$ this is clearly true because the steps
  are not executed. For $j\ge1$, observe that step
  \ref{alg:prepseudo:rec} stores exactly those values by induction
  hypothesis and it is called before \ref{alg:prepseudo:retrieve} and
  \ref{alg:prepseudo:frob}.
  
  Then, correctness follows from equation \eqref{eq:pseudotracecomp},
  in the same way as for the algorithm \alg{Big Pseudotrace}.

  As for the complexity, observe that the algorithm is essentially
  identical to \alg{Big Pseudotrace}. The only supplementary step is
  \ref{alg:prepseudo:for} that takes $p\Mult(p^id)$ operations and is
  thus dominated by step \ref{alg:prepseudo:frob}. The complexity is
  then the same as for the algorithm \alg{Big Pseudotrace}.
\end{proof}

Observe that, when $j=i$, we could have computed
$\PTr_{p^id}(\gamma_i)$ using a fast algorithm for the trace. This
yields only a constant speed-up over the algorithm we presented.

Finally, we remark that at each level $\U_i$, $(p-1)i +
\lfloor\log_2d\rfloor$ elements need to be stored, for a total space
occupation of $\left((p-1)i + \lfloor\log_2d\rfloor\right)p^id $
elements of $\F_p$ per level. That is $O(p^kd(pk+\log d))$ for the
whole tower.



% Local Variables:
% mode:flyspell
% ispell-local-dictionary:"british"
% End:
%
% LocalWords:  Schreier Artin pseudotrace frobenius bivariate memoization
% LocalWords:  precomputed precomputation precompute precomputations
