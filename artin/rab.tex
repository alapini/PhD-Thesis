We now investigate the case of general $n<p^id$. One sees that
\begin{equation*}
  \frob^{cp^jd + r}(v) = \frob^r\left(\left(\frob^{p^jd}\right)^c(v)\right),
\end{equation*}
Now, write $n = r+\sum_jc_jp^jd$ with $c_j<p$ for every $j$ and
$r=n\bmod d$, so that the sum has less than $\log_pn$ terms. We deduce
\begin{multline*}
  \Frob(i,n) = \Frob(i,r) + \sum_jc_j\Frob(i,p^jd) \le
  \Frob(i,r) +
  p\sum_{j=0}^{\lfloor\log_pn\rfloor} 
  O\left(\Mult(p^{i+1}d)\sum_{l=j+1}^i\log(p^ld)\right)=\\
  \Frob(i,r) + O\left(pi\Mult(p^{i+1}d)\log(p^id)\log_pn\right) =
  \Frob(i,r) + O\left(\Frob(i,d)p\log_pn\right),
\end{multline*}
so that the only problem left to solve is to compute $\frob^{n\bmod
  d}(v)$. This can be done in $O(d\Mult(p^id)\log p)$ by a naive
approach, but this is not satisfactory when $d$ is too large. A
classical solution is to use a modular composition approach
\cite{}. Recall from Section \ref{sec:introduction} that the result of
\alg{ModComp($f,g,h$)}, where $f$, $g$ and $h$ are polynomials of
degree at most $m$ in $\F_p[X]$, is the polynomial $f(g)\bmod h$. We
note $\ModComp(m)$ for its complexity in $\F_p$ operations.

The algorithm we give derives from equation \eqref{eq:frobeniuscomp}
and is essentially the same as \alg{Iterated Big Frobenius}, but we
cannot rely anymore on the structure of the tower at the bottom of the
recurrence. Again, we are going to suppose that
$\PTr_{2^e}(\gamma_i)^h$ is precomputed for any $i$, $1\le e<\log_2d$
and $1\le h<p$.

\begin{figure}[!htb]
  \begin{algorithm}
    {Iterated Little Frobenius}
    {$v\wrt\U_i$, $e$ such that $2^e<d$.}
    {$\frob^{2^e}(v)$.}
  \item \label{alg:l-frob:base-n} If $e = 0$, then return $v^p$.
  \item \label{alg:l-frob:modcomp} Else, if $i=0$,
    \begin{enumerate}
    \item \label{alg:l-frob:rec1} $X^{(e-1)}=$ Iterated Little Frobenius($x_0, e-1$);
    \item \label{alg:l-frob:e}compute $X^{(e)}=$ ModComp($X^{(e-1)},X^{(e-1)},Q_0$);
    \item \label{alg:l-frob:v-e} compute and return
      ModComp($v,X^{(e)},Q_0$).
    \end{enumerate}
  \item \label{alg:l-frob:i}Else,
    \begin{enumerate}
    \item \label{alg:l-frob:push} $v_0, \ldots, v_{p-1} = $
      Push-down($v$);
    \item \label{alg:l-frob:for} for $h = p-1$ to $0$
      \begin{enumerate}
      \item \label{alg:l-frob:rec} compute $\tilde{v}_h = $ Iterated
	Little Frobenius($v_h, e$);
      \item \label{alg:l-frob:comp} compute $t_h = \sum_{k=h}^{p-1}
	\binom{k}{h}\tilde{v}_k\PTr_{2^e}(\gamma_{i-1})^{k-h}$;
      \end{enumerate}
    \item \label{alg:l-frob:lift} compute and return Lift-up($t_0$,
    $\ldots$, $t_{p-1}$).
    \end{enumerate}
  \end{algorithm}
\end{figure}

\sloppy
\begin{theorem}
  \label{th:l-frob}
  The algorithm \alg{Iterated Little Frobenius} is correct and computes
  its result in
  $O\left(ep^i\ModComp(d) + i\Mult(p^{i+1}d)\log(p^id)\right)$
  $\F_p$-operations.
\end{theorem}
\fussy
\begin{proof}
  Now note $\Frob(i,2^e)$ the complexity of the algorithm on input
  $v\wrt\U_i$ and $e$, then $\Frob(i,2^0) = \Mult(p^id)\log p$.
  When $i=0$, step \ref{alg:l-frob:rec1} contributes
  $\Frob(0,2^{e-1})$ operations and steps \ref{alg:l-frob:e} and
  \ref{alg:l-frob:v-e} contribute $\ModComp(d)$ each, thus giving
  \begin{equation*}
    \Frob(0,2^e) = \Frob(0,2^{e-1}) + 2C(d) = 
    \Mult(d)\log p+2eC(d).
  \end{equation*}

  When $i\ge1$ the complexity analysis proceeds exactly like in the
  proof of theorem \ref{th:frob} and tells us
  \begin{multline*}
    \Frob(i,2^e) =
    p\Frob(i-1,2^e) + O\left(\Mult(p^{i+1}d)\log(p^id)\right)\le\\
    p^i\Frob(0,2^e) + O\left(i\Mult(p^{i+1}d)\log(p^id)\right) =
    O\left(ep^i\ModComp(d) + i\Mult(p^{i+1}d)\log(p^id)\right).
  \end{multline*}
\end{proof}


Now, if we want to compute $\frob^n(v)$ for any $r<d$, we can write it
in base $2$ as $\sum_{e=0}^cr_e2^e$ and use equation
\eqref{eq:frobeniussum} to compute
\begin{equation*}
  \frob^{n}(v) =
  \frob^{r_c2^c}\left(\cdots\left(\frob^{r_12^1}\left(\frob^{r_02^0}(v)\right)\right)\right)
  .
\end{equation*}
Observe that when $r_e=1$, $\frob^{r_e2^e}$ can be computed by
\alg{Iterated Little Frobenius}, while when $r_e=0$, $\frob^{r_e2^e}$
is simply the identity. We deduce
\begin{equation*}
  \Frob(i,r) = \sum_{e=0}^cr_e\Frob(i,2^e)\le
  \sum_{e=0}^{c}\Frob(i,2^e)
  .
\end{equation*}

We can now use remark \ref{rk:memo} and store (at least temporarily)
the values of $\frob^{2^e}(x_0)$ for $0\le e<c$. This makes
$\Frob(i,2^e)$ drop down to $O\left(p^i\ModComp(d) +
i\Mult(p^{i+1}d)\log(p^id)\right)$ when $e<c$, while letting unchanged
$\Frob(i,2^c)$.  Since $c\le\log_2r$, we deduce that
\begin{equation*}
  \Frob(i,r) \le \Frob(i,2^c) + \sum_{e=0}^{c-1}\Frob(i,2^e)\le
  O\left(p^i\ModComp(d)\log r + i\Mult(p^{i+1}d)\log(p^id)\log r\right).
\end{equation*}

Putting things together, we deduce the following
\sloppy
\begin{corollary}
  The number of $\F_p$ operations needed to compute
  $\frob^n(v)\wrt\U_i$ is $O\left(p^i\ModComp(d)\log(n\bmod d) +
  pi\Mult(p^{i+1}d)\log(p^id)\log_pn\right)$.
\end{corollary}
\fussy




\begin{figure}[h]
  \begin{algorithm}
    {Little Pseudotrace}
    {$v\wrt\U_i$, $1\le n\le d$.}
    {$T_{n}(v)$.}
  \item \label{alg:l-pseudo:base}If $n = 1$, then return $v$.
  \item \label{alg:l-pseudo:even}Else, if $n=2^e$, 
    \begin{enumerate}
    \item \label{alg:l-pseudo:rec}compute $t = $ Little Pseudotrace($v$,
      $2^{e-1}$);
    \item \label{alg:l-pseudo:frob} compute $T = $ Iterated Little
      Frobenius($t$, $e-1$);
    \item \label{alg:l-pseudo:sum}return $t + T$.
    \end{enumerate}
  \item \label{alg:l-pseudo:odd}Else, let $2^e<n< 2^{e+1}$,
    \begin{enumerate}
    \item compute $t_0 = $ Little Pseudotrace($v$, $2^e$);
    \item compute $t_1 = $ Little Pseudotrace($v$, $n \bmod 2^e$);
    \item \label{alg:l-pseudo:frob2}compute $T_1 = $ Iterated Little
      Frobenius($t_1$, $e$);
    \item compute and return $t_0 + T_1$.
    \end{enumerate}
  \end{algorithm}
\end{figure}

\sloppy
\begin{theorem}
  \label{th:l-pseudo}
  The algorithm \alg{Little Pseudotrace} is correct and computes its
  output in $O\left(p^i\ModComp(d)\log n +
  i\Mult(p^{i+1}d)\log(p^id)\log n\right)$ $\F_p$-operations.
\end{theorem}
\fussy
\begin{proof}
  Correctness of step \ref{alg:l-pseudo:base} is evident. Step
  \ref{alg:l-pseudo:even} follows from equation
  \eqref{eq:pseudotracecomp} and $2^{e-1}<d$, thus step
  \ref{alg:l-pseudo:frob} is correct. Step \ref{alg:l-pseudo:odd}
  follows from equation \eqref{eq:pseudotracesum} and $2^e<n\le d$,
  thus step \ref{alg:l-pseudo:frob2} is correct.

  Note $\Ptr(i,n)$ the complexity of the algorithm on input
  $v\wrt\U_i$ and $n$. Clearly, $\Ptr(i,1)=O(1)$. From step
  \ref{alg:l-pseudo:even} we deduce
  \[\Ptr(i,2^c) = \Ptr(i,2^{c-1}) + \Frob(i,c-1) + O(p^id)\]
  and we can ignore the term $O(p^id)$. As a consequence
  \begin{equation*}
    \Ptr(i,2^c) = \sum_{e=0}^{c-1} \Frob(i,2^e).
  \end{equation*}
  We now use again remark \ref{rk:memo} and store $\frob^{2^e}(x_0)$
  for $0\le e\le\log_2n$. This makes $\Frob(i,2^e)$ drop to
  $O\left(p^i\ModComp(d) + i\Mult(p^{i+1}d)\log(p^id)\right)$ and
  \begin{equation*}
    \Ptr(i,2^c) = O\left(cp^i\ModComp(d) +
    ci\Mult(p^{i+1}d)\log(p^id)\right) .
  \end{equation*}

  From step \ref{alg:l-pseudo:odd} we deduce that if $2^c<n<2^{c+1}$
  \begin{equation*}
    \Ptr(i,n) =
    \Ptr(i, 2^c) + \Ptr(i, n\bmod 2^c) + \Frob(i, 2^c) + O(p^id)
  \end{equation*}
  and we can ignore the term $O(p^id)$. Let $\sum_{e=0}^cn_e2^e$ be
  the binary expansion of $n$, then
  \begin{equation}
    \label{eq:ptr-rec}
    \Ptr(i,n) = \sum_{e=1}^c n_e\left(\Ptr(i, 2^e) + \Frob(i,2^e)\right)
    .
  \end{equation}
  Observe that all the recursive calls in the algorithm have $v$ as
  their first argument. Thus we can again use a dynamic programming
  technique to compute just once the $\PTr_{2^e}(v)$'s, in fact they
  are all computed for $1\le e \le c$ by step \ref{alg:l-pseudo:rec}
  during the call to \alg{Little Pseudotrace($v,2^c$)}. As a
  consequence, equation \eqref{eq:ptr-rec} becomes
  \begin{equation*}
    \Ptr(i,n) = \Ptr(i, 2^c) + \sum_{e=1}^c n_e\Frob(i,2^e) =
    O\left(cp^i\ModComp(d) + ci\Mult(p^{i+1}d)\log(p^id)\right)
    .
  \end{equation*}
  Observing that $c\le\log_2n$ concludes the proof.
\end{proof}

Now, to compute $\PTr_n(v)$ for a generic $n$, let $n = r +
\sum_{j=0}^{c}c_jp^jd$ with $c_j<p$ and $r<d$, then by equations
\eqref{eq:pseudotracecomp} and \eqref{eq:pseudotracesum}
\begin{equation*}
  \PTr_n(v) =
  \PTr_r(v) + \frob^r\left(
  \sum_{h=0}^{c_0-1}\left(\frob^{d}\right)^h(\PTr_d(v)) + \left(\frob^d\right)^{c_0}\left(
  \sum_{h=0}^{c_1-1}\left(\frob^{pd}\right)^h(\PTr_{pd}(v)) + \cdots
  \right)
  \right),
\end{equation*}
so that in the worse case
\begin{equation*}
  \Ptr(i,n) = \Ptr(i,r) + \sum_{j=0}^c \Ptr(i,p^jd) + O(p)\Frob(i,p^jd)
  .
\end{equation*}
Observing that the $\PTr_{p^jd}(v)$ can be computed just once while
computing \alg{Big Pseudotrace(v,c)}, we have
\begin{multline*}
  \Ptr(i,n) = \Ptr(i,r) + \Ptr(i,p^cd) + O(p)\sum_{j=0}^c \Frob(i,p^jd) =
  \Ptr(i,r) + \Ptr(i,p^cd) + O\left(pic\Mult(p^{i+1}\log(p^id)\right)
  .
\end{multline*}
Using the results of theorems \ref{th:l-pseudo} and \ref{th:b-pseudo},
we conclude
\begin{equation*}
  \Ptr(i,n) = O\left(p^i\ModComp(d)\log d +
  (pc +\log d)i\Mult(p^{i+1}d)\log(p^id)\right) =
  O\left( \Ptr(i, p^cd) \right) .
\end{equation*}

